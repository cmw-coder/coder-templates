.. _topics-PC操作:


PC操作
================
自动化测试中，PC是常见的辅助自动化的工具。根据PC不同的作用，框架将其分为 ``LocalHost`` 、 ``PCServer`` 、 ``ProgramServer`` 三大类：

- ``LocalHost`` ：执行主机，用于执行脚本，并提供相应的辅助功能；
- ``PCServer`` ： 不操作主机，其提供了某功能（如DNS、FTP），但脚本执行时并不会操作它们；
- ``ProgramServer`` ：可操作主机，常用于代表 Linux 系统，通过向其下发命令，辅助自动化测试；

-------------
LocalHost类
-------------
除执行脚本外，提供若干辅助功能。在使用辅助功能前，通常需要其与设备建立连接关系。


SSH登录/登出
-----------------
对应的方法为： ``ssh_login`` 、 ``ssh_logout``


.. code-block:: python
    :linenos:

    # 验证设备DUT的ssh server登录功能，参数分别为地址、用户名、密码、端口号（默认22）
    # 登录成功，返回值为ssh连接对象（用于后续关闭ssh登录连接），否则返回None，并打印失败信息
    client = gl.HOST.ssh_login('100.1.1.28', 'test', '123_abc_456!', port=22)
    
    with atf_assert('检查DUT ssh server功能，预期可以登录成功') as ars:
        if client:
            ars.append(True)

    # ssh登出，如不指定ssh连接对象，会关闭上一次打开的ssh登录连接
    gl.HOST.ssh_logout(client)


FTP客户端
-----------------
对应的方法为： ``ftp_get`` ``ftp_put``


.. code-block:: python
    :linenos:

    # 验证设备DUT的ftp server文件下载功能，参数分别为地址:端口（默认21）、用户名、密码、源文件路径、目的文件路径
    # 下载成功返回True，失败返回False
    
    # 下载到当前脚本所在目录，文件名为user.csv
    gl.HOST.ftp_get("127.0.0.1:21", "anonymous", "anonymous", "user.csv")

    # 下载到当前脚本所在目录，文件名修改为 local_user.csv
    gl.HOST.ftp_get("127.0.0.1:21", "anonymous", "anonymous", "user.csv", 'local_user.csv')

    # 下载到d盘，文件名修改为 another_user.csv
    gl.HOST.ftp_get("127.0.0.1:21", "anonymous", "anonymous", "user.csv", 'd:/another_user.csv')
    
    # 验证设备DUT的ftp server文件上传功能，参数分别为地址:端口（默认21）、用户名、密码、源文件路径、目的文件路径
    # 下载成功返回True，失败返回False
    
    # 上传到FTP server配置的路径，文件名为user.csv
    gl.HOST.ftp_put("127.0.0.1:21", "anonymous", "anonymous", "D:/user.csv")

    # 上传到FTP server配置的路径，文件名为server_user.csv
    gl.HOST.ftp_put("127.0.0.1:21", "anonymous", "anonymous", "D:/user.csv", "server_user.csv")

    # 上传到FTP server配置的路径的子目录 yyy，文件名为another_user.csv
    gl.HOST.ftp_put("127.0.0.1:21", "anonymous", "anonymous", "D:/user.csv", "./yyy/another_user.csv")
    

FTP服务端
-----------------
对应的方法为： ``start_ftp_server`` ``stop_ftp_server``


.. code-block:: python
    :linenos:

    # 在执行机上开启ftp服务，参数分别为ftp服务器地址(支持ipv4和ipv6)，由用户名、密码、源文件路径组成的元组（多个账户时为元组组成的列表），端口号（默认21）
    # 成功返回True, 否则返回False
    res = gl.HOST.start_ftp_server('192.168.1.1', ('user1', 'pass1', 'D:/ftpserver'), port=3100)

    # do something

    # 关闭执行机上的ftp服务
    gl.HOST.stop_ftp_server()

    # 创建多个账户
    res = gl.HOST.start_ftp_server('192.168.1.1', [('user1', 'pass1', 'D:/tftpserver'), ('user2', 'pass2', 'D:/ftpserver2')], port=3100)

    # do something

    # 关闭执行机上的ftp服务
    gl.HOST.stop_ftp_server()

.. note:: VTP-CLOUD暂停时，会阻塞所有I/O，导致FTP SERVER不可用。所以调试时，在do something处添加长时间的等待，用于代替暂停。



TFTP服务端
-----------------
对应的方法为： ``start_tftp_server`` ``stop_tftp_server``


.. code-block:: python
    :linenos:

    # 在执行机上开启tftp服务，参数分别为tftp服务器地址(支持ipv4和ipv6)，源文件路径
    # 成功返回True, 否则返回False
    res = gl.HOST.start_tftp_server('192.168.1.1', 'D:/tftpserver')

    # do something

    # 关闭执行机上的tftp服务
    gl.HOST.stop_tftp_server()

.. note:: VTP-CLOUD暂停时，会阻塞所有I/O，导致TFTP SERVER不可用。所以调试时，在do something处添加长时间的等待，用于代替暂停。


日志主机
-----------------
自动化测试中，通常使用3CDeamon工具作为日志主机，但存在安装、部署等问题，框架提供的日志主机，不需要第三方工具，使用更加方便。

对应的方法为： ``start_syslog_host`` 、 ``read_syslog`` 、 ``stop_syslog_host``


.. code-block:: python
    :linenos:

    # 启动日志主机，参数host为PC的地址，port默认为514
    gl.HOST.start_syslog_host(host=gl.HOST.PORT1.ip, port=514)

    # do something
    
    # 读取syslog日志, 通过count可以指定读取syslog条数， 默认读取当前所有，每条syslog间使用\n分隔，默认等待时间为5s
    
    # 读取1条syslog，默认等待时间为5s，等待时间内，没有收到syslog，则返回空
    res = gl.HOST.read_syslog(count=1)

    # 读取100条syslog，配置等待时间为10s，等待时间内，如果没有收到100条syslog，则返回已经收到的所有syslog
    res = gl.HOST.read_syslog(count=100, timeout=10)
    
    # 读取所有syslog，每条syslog间使用\n分隔，默认等待时间为5s
    res = gl.HOST.read_syslog()

    # 关闭日志主机
    gl.HOST.stop_syslog_host()
    


数据库操作
-----------------
对于数据库的操作，框架提供4个方法：连接数据库、执行sql语句、读取sql语句的内容、关闭数据库。对应的方法及使用示例如下：


1、 ``connect_db`` 用于数据库连接，成功返回True，失败返回False。连接数据库失败，后续所有的操作都会提示数据库连接失败。参数如下：

    - ``host`` 数据库地址，字符串，必选参数
    - ``user`` 数据库用户名，字符串，必选参数
    - ``password`` 数据库密码，字符串，必选参数
    - ``database`` 数据库名称，字符串，必选参数
    - ``db_type`` 数据库名称，字符串，可选参数，只支持MySql和PostgreSQL，默认为 MySql


2、 ``excute_db_sql`` 用于执行sql语句，成功返回True，失败返回False。参数如下：

    - ``sql`` 要执行的sql语句，字符串，必选参数


3、 ``read_db_sql`` 用于读取sql语句执行后的信息，只支持读取类的sql语句，成功返回前一条sql语句的返回信息，类型为列表，失败返回False。无入参。


4、 ``close_db`` 用于关闭数据库连接，成功返回True，失败返回False。无入参，需要与 ``connect_db`` 成对使用。


.. code-block:: python
    :linenos:

    # 连接数据库
    gl.HOST.connect_db(host='192.168.1.1', user='root', password='123', database='demo', db_type='MySql')

    # 创建表
    gl.HOST.excute_db_sql("CREATE TABLE IF NOT EXISTS users (id INT AUTO_INCREMENT PRIMARY KEY, name VARCHAR(255))")

    # 插入数据
    gl.HOST.excute_db_sql("INSERT INTO users (name) VALUES ('Alice')")
    gl.HOST.excute_db_sql("INSERT INTO users (name) VALUES ('Bob')")

    # 查询数据表users，并按行打印user表的内容
    gl.HOST.excute_db_sql("SELECT * FROM users")

    if data := gl.HOST.read_db_sql():
        for row in data:
            print(row)

    # 关闭数据库连接
    gl.HOST.close_db()


收发包功能
--------------------


发包功能
~~~~~~~~~~~~~~~~~~~~

框架提供执行机指定网卡发包功能，方便用户在需要发送少量报文时使用。主要使用以下接口：

框架提供的方法 ``send_packet`` 用于发送报文，此接口无返回值，入参解释如下：

- ``pkt`` 需要发送的报文，字符串或列表，为scapy构造好的报文
- ``count`` 指定发送pkt的次数，整形，默认为1
- ``inter`` 报文发送间隔，浮点数，默认为0，单位为秒


框架提供的方法 ``send_and_receive_packet`` 用于发送需要获取回包的报文，返回值是一个由两个部分组成的元组：(answered, unanswered):answered 是一个列表，其中包含接收到的响应报文;unanswered 是一个列表，其中包含未收到响应的请求报文。入参解释如下：

- ``pkt`` 需要发送的报文，字符串或列表，为scapy构造好的报文
- ``timeout`` 超时时间，最后一个报文发送完等待回包时间

这两个接口的使用方法不单独举例，具体使用方法可参考 **scapy构造报文** 小节。

.. note:: 用户使用框架提供的发送报文的方法，所构造的报文必须从Ether层开始构造，即接口send_packet和send_and_receive_packet从数据链路层开始发包。


构造报文
~~~~~~~~~~~~~~~~~~~~

待发送的报文由用户在脚本中借助scapy库进行构造，框架仅提供发送报文的接口，不提供各类报文构造方法。

scapy是一个强大的Python网络工具，可以使用scapy的各种函数和类来创建各种类型的报文，如Ethernet、IP、TCP、UDP等，下面将对scapy构包进行举例：


构造IP报文，使用send_packet接口发送报文


.. code-block:: python
    :linenos:
    :emphasize-lines: 2,5,24

    # 引入库文件
    from scapy.all import *

    # 创建IP报文，源ip为13.0.0.1，目标IP地址为10.0.0.1
    packet = Ether(dst="ff:ff:ff:ff:ff:ff")/IP(src="13.0.0.1",dst="10.0.0.1")
    # 查看IP报文头支持的参数，其余类似
    IP().show()
    # ###[ IP ]### 
    #   version   = 4
    #   ihl       = None
    #   tos       = 0x0
    #   len       = None
    #   id        = 1
    #   flags     = 
    #   frag      = 0
    #   ttl       = 64
    #   proto     = ip
    #   chksum    = None
    #   src       = 10.170.26.17
    #   dst       = 127.0.0.1
    #   \options   \
    
    # 发送IP报文，数量为10个，间隔为1s
    gl.HOST.send_packet(packet, count=10, inter=1)


构造ARP请求报文，使用send_and_receive_packet接口发送报文并获得回包

.. code-block:: python
    :linenos:
    :emphasize-lines: 2,5,14

    # 引入库文件
    from scapy.all import *

    # 创建ARP请求报文，目标IP地址为10.0.0.1
    arp_request = Ether(dst="ff:ff:ff:ff:ff:ff")/ARP(op=1, pdst="10.0.0.1")
    # 查看Ether报文头支持的参数，其余类似
    Ether().show()
    # ###[ Ethernet ]### 
    #   dst       = ff:ff:ff:ff:ff:ff
    #   src       = 9c:7b:ef:42:cf:87
    #   type      = 0x9000
    # 发送ARP请求并接收响应
    # send_and_receive_packet接口返回值为包含两个列表元素的元组，第一个元素为接收到的响应报文列表，第二个元素为未收到响应的请求报文列表
    arp_response = gl.HOST.send_and_receive_packet(arp_request, timeout=1)[0]


构造ICMP报文，使用send_and_receive_packet接口发送报文并获得回包

.. code-block:: python
    :linenos:
    :emphasize-lines: 2,5,12

    # 引入库文件
    from scapy.all import *

    # 创建ICMP报文，目标MAC地址为74:ea:c8:ba:27:da，目标IP地址为10.0.0.1
    icmp_packet = Ether(dst="74:ea:c8:ba:27:da")/IP(dst="10.0.0.1")/ICMP()

    # 查看报文构造内容
    print(icmp_packet.summary())
    # Ether / IP / ICMP 10.153.224.68 > 10.0.0.1 echo-request 0

    # 发送ICMP报文并接收响应
    icmp_response = gl.HOST.send_and_receive_packet(icmp_packet, timeout=1)[0]



构造IGMP报文

.. code-block:: python
    :linenos:
    :emphasize-lines: 2,5,9

    # 引入库文件
    from scapy.all import *

    # 构造IGMP报文，由于IGMP不在scapy.all中，需要做额外引用
    from scapy.contrib.igmp import IGMP
    igmp_packet = Ether()/IP(dst="62.22.14.4")/IGMP()

    # 打印构造的IGMP报文
    print(igmp_packet.summary())
    #Ether / IP / IGMP: 10.153.224.68 > 62.22.14.4 Group Membership Query 0.0.0.0


**用Raw添加自定义原始字节序列或数据**

.. code-block:: python
    :linenos:
    :emphasize-lines: 2,5

    # 引入库文件
    from scapy.all import *

    # 创建IP报文，源ip为13.0.0.1，目标IP地址为10.0.0.1
    packet = Ether(dst="ff:ff:ff:ff:ff:ff")/IP(src="13.0.0.1",dst="10.0.0.1")/Raw(b'\x01\x02\x03\x04')
    
    # 输出报文的摘要信息
    print(packet.summary())
    # Ether / 13.0.0.1 > 10.0.0.1 ip / Raw



**对于构造好的报文不足指定长度，可以用Padding添加**

.. code-block:: python
    :linenos:
    :emphasize-lines: 2,5,12

    # 引入库文件
    from scapy.all import *

    # 创建IP报文，源ip为13.0.0.1，目标IP地址为10.0.0.1
    packet = Ether(dst="ff:ff:ff:ff:ff:ff")/IP(src="13.0.0.1",dst="10.0.0.1")
    
    # 查看报文长度
    print(len(packet))

    # 如果需要构造指定长度（128）的IP报文，但是当前不足，需要补齐
    # 计算报文中已有的长度
    existing_length = len(packet)

    # 计算需要添加的填充长度
    padding_length = 128 - existing_length
    # 添加填充
    padding = Padding("\x00" * padding_length)
    packet = packet / padding

.. note:: Padding 字段用于添加无意义的字节以满足长度要求，而 Raw 字段用于添加自定义的原始数据，用户可以根据需求选择使用哪种字段类型。


对于构造好的报文，或者回包，可以采用以下方式获取 **报文字段信息**，可以检查构造的报文是否符合预期，以ICMP报文举例

.. code-block:: python
    :linenos:
    :emphasize-lines: 2,5,8,12,40,44

    # 引入库文件
    from scapy.all import *

    # 创建ICMP报文，目标MAC地址为74:ea:c8:ba:27:da，目标IP地址为10.0.0.1
    icmp_packet = Ether(dst="74:ea:c8:ba:27:da")/IP(dst="10.0.0.1")/ICMP()

    # 查看报文构造内容
    print(icmp_packet.summary())
    # Ether / IP / ICMP 10.153.224.68 > 10.0.0.1 echo-request 0

    # 查看报文各字段内容
    icmp_packet.show()
    #  ###[ Ethernet ]###
    #    dst       = 74:ea:c8:ba:27:da
    #    src       = 00:50:56:bf:ab:b7
    #    type      = IPv4
    #    ###[ IP ]###
    #        version   = 4
    #        ihl       = None
    #        tos       = 0x0
    #        len       = None
    #        id        = 1
    #        flags     =
    #        frag      = 0
    #        ttl       = 64
    #        proto     = icmp
    #        chksum    = None
    #        src       = 10.153.224.68
    #        dst       = 10.0.0.1
    #        \options   \
    #    ###[ ICMP ]###
    #            type      = echo-request
    #            code      = 0
    #            chksum    = None
    #            id        = 0x0
    #            seq       = 0x0
    #            unused    = ''
    
    # 查看构造报文的IP报文头version
    print(icmp_packet[IP].dst)
    # 10.0.0.1

    # 发送ICMP报文并接收响应
    icmp_response = gl.HOST.send_and_receive_packet(icmp_packet, timeout=1)[0]
    for pkt in icmp_response:
        pkt.show()
    # ###[ Ethernet ]###
    #   dst       = 00:50:56:bf:ab:b7
    #   src       = 74:ea:cb:61:b2:61
    #   type      = IPv4
    #   ###[ IP ]###
    #       version   = 4
    #       ihl       = None
    #       tos       = 0x0
    #       len       = None
    #       id        = 1
    #       flags     =
    #       frag      = 0
    #       ttl       = 64
    #       proto     = icmp
    #       chksum    = None
    #       src       = 10.0.0.1
    #       dst       = 10.153.224.68
    #       \options   \
    #   ###[ ICMP ]###
    #           type      = echo-reply
    #           code      = 0
    #           chksum    = None
    #           id        = 0x0
    #           seq       = 0x0
    #           unused    = ''
    #           


构造报文时，可以分别创建报文头，然后再构成完整报文，以ARP请求报文构造举例

.. code-block:: python
    :linenos:
    :emphasize-lines: 2,5-7,9

    # 引入库文件
    from scapy.all import *

    # 创建ARP请求报文，目标IP地址为10.0.0.1，以下构造代码等价于arp_request = Ether(dst="ff:ff:ff:ff:ff:ff") / ARP(op=1, pdst="10.0.0.1")
    ether_header = Ether(dst="ff:ff:ff:ff:ff:ff")
    arp_header = ARP(op=1, pdst="10.0.0.1")
    arp_request = ether_header /arp_header
    # 查看报文arp_request内容
    arp_request.show()
    # ###[ Ethernet ]###
    #   dst       = ff:ff:ff:ff:ff:ff
    #   src       = 00:50:56:bf:ab:b7
    #   type      = ARP
    #   ###[ ARP ]###
    #       hwtype    = Ethernet (10Mb)
    #       ptype     = IPv4
    #       hwlen     = None
    #       plen      = None
    #       op        = who-has
    #       hwsrc     = 00:50:56:bf:ab:b7
    #       psrc      = 10.153.224.68
    #       hwdst     = 00:00:00:00:00:00
    #       pdst      = 10.0.0.1
    

**构造变化的报文示例**

示例1：构造ip地址变化的IP报文，此方法在构造报文时将指定字段传入列表，即可构造对应的报文


.. code-block:: python
    :linenos:
    :emphasize-lines: 2,5,6,16-18,28-32

    # 引入库文件
    from scapy.all import *

    # 创建IP报文，源ip为13.0.0.1，目标IP地址为10.0.0.1-10.0.0.9
    dst_ip_list = ['10.0.0.'+str(x) for x in range(1,10)]
    packet = Ether(dst="ff:ff:ff:ff:ff:ff")/IP(src="13.0.0.1",dst=dst_ip_list)/('0'*80)
    # 查看IP报文头支持的参数，其余类似
    print(packet.summary())
    # Ether / 192.168.2.254 > ['192.168.1.1', '192.168.1.2', '192.168.1.3', '192.168.1.4', '192.168.1.5', '192.168.1.6', '192.168.1.7', '192.168.1.8', '192.168.1.9'] ip / Raw
    
    # 发送报文
    gl.HOST.send_packet(packet)
    # Sent 9 packets.

    # 创建IP报文，源ip为13.0.0.1-13.0.0.9，目标IP地址为10.0.0.1-10.0.0.9
    src_ip_list = ['13.0.0.'+str(x) for x in range(1,10)]
    dst_ip_list = ['10.0.0.'+str(x) for x in range(1,10)]
    packet = Ether(dst="ff:ff:ff:ff:ff:ff")/IP(src=src_ip_list,dst=dst_ip_list)/('0'*80)
    # 查看IP报文头支持的参数，其余类似
    print(packet.summary())
    # Ether / ['192.168.2.1', '192.168.2.2', '192.168.2.3', '192.168.2.4', '192.168.2.5', '192.168.2.6', '192.168.2.7', '192.168.2.8', '192.168.2.9'] > ['192.168.1.1', '192.168.1.2', '192.168.1.3', '192.168.1.4', '192.168.1.5', '192.168.1.6', '192.168.1.7', '192.168.1.8', '192.168.1.9'] ip / Raw
    
    # 发送报文
    gl.HOST.send_packet(packet)
    # Sent 81 packets.
    
    # 如果只想创建源ip为13.0.0.1-13.0.0.9，目标IP地址为10.0.0.1-10.0.0.9一一对应，只发九个报文
    packet = Ether(dst="ff:ff:ff:ff:ff:ff")/IP(src="13.0.0.1",dst="10.0.0.1")/('0'*80)
    for i in range(1,10):
        packet[IP].src = '13.0.0.' + str(i)
        packet[IP].dst = '10.0.0.' + str(i)
        gl.HOST.send_packet(packet)
    # Sent 9 packets.


示例2：此方法采用python库，可构造支持步长变化较大的情况，对于构造报文指定字段为整形的，可以直接采用元组传值；当指定字段采用列表进行传参时，生成的报文为


.. code-block:: python
    :linenos:
    :emphasize-lines: 2,10-15,18,29-34,37,48-53,56

    # 引入库文件
    from scapy.all import *

    # 变化为源ipv4地址，步长为100，数量为10
    # 定义起始IP地址和递增步长（递减步长为负）
    start_ip = "192.168.0.1"
    # 定义要生成的IP地址数量
    ip_count = 10
    # 循环生成递增的源IP地址列表
    start_ip_list = ["192.168.0.1"]
    for i in range(1, ip_count):
        # 递增IP地址
        start_ip = IPAddress.incr_ip_address(str(start_ip),step=100)
        print(start_ip)
        start_ip_list.append(str(start_ip))
    
    # 构造报文，并使用递增的IP地址作为源IP
    pkt = Ether() / IP(src=start_ip_list, dst="10.0.0.1") / UDP(dport=12345)
    # 发送报文
    gl.HOST.send_packet(pkt)


    # 变化为源ipv6地址，步长为20，数量为10
    # 定义起始IPv6地址和递增步长（递减步长为负）
    start_ipv6 = '2001:db8::1'
    # 定义要生成的IPv6地址数量
    ipv6_count = 10
    # 循环生成递增的IPv6地址
    start_ipv6_list = ['2001:db8::1']
    for i in range(1, ipv6_count):
        # 递增IPv6地址
        start_ipv6 = IPAddress.incr_ipv6_address(str(start_ipv6),step=100)
        print(start_ipv6)
        start_ipv6_list.append(str(start_ipv6))

    # 构造报文，并使用递增的IPv6地址作为源IPv6地址
    pkt = Ether() / IPv6(src=start_ipv6_list, dst="2001:db8::2") / ICMPv6EchoRequest()
    # 发送报文
    gl.HOST.send_packet(pkt)


    # 变化为源mac地址，步长为20，数量为10
    # 定义起始MAC地址和递增步长（递减步长为负）
    start_mac = "00:11:22:33:44:55"
    # 定义要生成的MAC地址数量
    mac_count = 10
    # 循环生成递增的MAC地址
    start_mac_list = ["00:11:22:33:44:55"]
    for i in range(mac_count):
        # 递增MAC地址
        start_mac = IPAddress.incr_mac_address(str(start_mac),increment=20)
        print(start_mac)
        start_mac_list.append(str(start_mac))

    # 构造报文，并使用递增的MAC地址作为源MAC
    pkt = Ether(src=start_mac_list, dst="00:00:00:00:00:00") / IP(dst="10.0.0.1") / UDP(dport=12345)
    # 发送报文
    gl.HOST.send_packet(pkt)


示例3：此方法指定字段采用列表或者指定形式进行传参时，也可以批量生成的报文


.. code-block:: python
    :linenos:
    :emphasize-lines: 2,5,26,36,51,62

    # 引入库文件
    from scapy.all import *

    # 构造IP报文，目的ip地址为1.1.1.96-1.1.1.111，写法如下
    pkt = Ether()/IP(dst='1.1.1.100/28')
    [p for p in pkt]
    # [<Ether  type=IPv4 |<IP  dst=1.1.1.96 |>>,
    # <Ether  type=IPv4 |<IP  dst=1.1.1.97 |>>,
    # <Ether  type=IPv4 |<IP  dst=1.1.1.98 |>>,
    # <Ether  type=IPv4 |<IP  dst=1.1.1.99 |>>,
    # <Ether  type=IPv4 |<IP  dst=1.1.1.100 |>>,
    # <Ether  type=IPv4 |<IP  dst=1.1.1.101 |>>,
    # <Ether  type=IPv4 |<IP  dst=1.1.1.102 |>>,
    # <Ether  type=IPv4 |<IP  dst=1.1.1.103 |>>,
    # <Ether  type=IPv4 |<IP  dst=1.1.1.104 |>>,
    # <Ether  type=IPv4 |<IP  dst=1.1.1.105 |>>,
    # <Ether  type=IPv4 |<IP  dst=1.1.1.106 |>>,
    # <Ether  type=IPv4 |<IP  dst=1.1.1.107 |>>,
    # <Ether  type=IPv4 |<IP  dst=1.1.1.108 |>>,
    # <Ether  type=IPv4 |<IP  dst=1.1.1.109 |>>,
    # <Ether  type=IPv4 |<IP  dst=1.1.1.110 |>>,
    # <Ether  type=IPv4 |<IP  dst=1.1.1.111 |>>]


    # 构造UDP报文dport为100至110，步长为2的报文
    pkt = Ether(src="00:11:22:33:44:55", dst="00:00:00:00:00:00") / IP(dst="10.0.0.1") / UDP(dport=(100,110,2))
    [p for p in pkt]
    # [<Ether  dst=00:00:00:00:00:00 src=00:11:22:33:44:55 type=IPv4 |<IP  frag=0 proto=udp dst=10.0.0.1 |<UDP  dport=100 |>>>,
    # <Ether  dst=00:00:00:00:00:00 src=00:11:22:33:44:55 type=IPv4 |<IP  frag=0 proto=udp dst=10.0.0.1 |<UDP  dport=102 |>>>,
    # <Ether  dst=00:00:00:00:00:00 src=00:11:22:33:44:55 type=IPv4 |<IP  frag=0 proto=udp dst=10.0.0.1 |<UDP  dport=104 |>>>,
    # <Ether  dst=00:00:00:00:00:00 src=00:11:22:33:44:55 type=IPv4 |<IP  frag=0 proto=udp dst=10.0.0.1 |<UDP  dport=106 |>>>,
    # <Ether  dst=00:00:00:00:00:00 src=00:11:22:33:44:55 type=IPv4 |<IP  frag=0 proto=udp dst=10.0.0.1 |<UDP  dport=108 |>>>,
    # <Ether  dst=00:00:00:00:00:00 src=00:11:22:33:44:55 type=IPv4 |<IP  frag=0 proto=udp dst=10.0.0.1 |<UDP  dport=110 |>>>]

    # 构造UDP报文dport为100至110，步长为1的报文
    pkt = Ether(src="00:11:22:33:44:55", dst="00:00:00:00:00:00") / IP(dst="10.0.0.1") / UDP(dport=(100,110))
    [p for p in pkt]
    # [<Ether  dst=00:00:00:00:00:00 src=00:11:22:33:44:55 type=IPv4 |<IP  frag=0 proto=udp dst=10.0.0.1 |<UDP  dport=100 |>>>,
    # <Ether  dst=00:00:00:00:00:00 src=00:11:22:33:44:55 type=IPv4 |<IP  frag=0 proto=udp dst=10.0.0.1 |<UDP  dport=101 |>>>,
    # <Ether  dst=00:00:00:00:00:00 src=00:11:22:33:44:55 type=IPv4 |<IP  frag=0 proto=udp dst=10.0.0.1 |<UDP  dport=102 |>>>,
    # <Ether  dst=00:00:00:00:00:00 src=00:11:22:33:44:55 type=IPv4 |<IP  frag=0 proto=udp dst=10.0.0.1 |<UDP  dport=103 |>>>,
    # <Ether  dst=00:00:00:00:00:00 src=00:11:22:33:44:55 type=IPv4 |<IP  frag=0 proto=udp dst=10.0.0.1 |<UDP  dport=104 |>>>,
    # <Ether  dst=00:00:00:00:00:00 src=00:11:22:33:44:55 type=IPv4 |<IP  frag=0 proto=udp dst=10.0.0.1 |<UDP  dport=105 |>>>,
    # <Ether  dst=00:00:00:00:00:00 src=00:11:22:33:44:55 type=IPv4 |<IP  frag=0 proto=udp dst=10.0.0.1 |<UDP  dport=106 |>>>,
    # <Ether  dst=00:00:00:00:00:00 src=00:11:22:33:44:55 type=IPv4 |<IP  frag=0 proto=udp dst=10.0.0.1 |<UDP  dport=107 |>>>,
    # <Ether  dst=00:00:00:00:00:00 src=00:11:22:33:44:55 type=IPv4 |<IP  frag=0 proto=udp dst=10.0.0.1 |<UDP  dport=108 |>>>,
    # <Ether  dst=00:00:00:00:00:00 src=00:11:22:33:44:55 type=IPv4 |<IP  frag=0 proto=udp dst=10.0.0.1 |<UDP  dport=109 |>>>,
    # <Ether  dst=00:00:00:00:00:00 src=00:11:22:33:44:55 type=IPv4 |<IP  frag=0 proto=udp dst=10.0.0.1 |<UDP  dport=110 |>>>]

    # 构造IP报文，ttl值为1，2，5，6，7，8，9
    pkt = Ether()/IP(ttl=[1,2,(5,9)])
    [p for p in pkt]
    # [<Ether  type=IPv4 |<IP  ttl=1 |>>,
    # <Ether  type=IPv4 |<IP  ttl=2 |>>,
    # <Ether  type=IPv4 |<IP  ttl=5 |>>,
    # <Ether  type=IPv4 |<IP  ttl=6 |>>,
    # <Ether  type=IPv4 |<IP  ttl=7 |>>,
    # <Ether  type=IPv4 |<IP  ttl=8 |>>,
    # <Ether  type=IPv4 |<IP  ttl=9 |>>]

    # 当构造报文时有两个字段同时变化，生成的报文组为所有字段之间的笛卡尔积生成，如下所示
    pkt = Ether()/IP(dst='1.1.1.100/30', ttl=[1,2,(5,9)])
    [p for p in pkt]
    # [<Ether  type=IPv4 |<IP  ttl=1 dst=1.1.1.100 |>>,
    # <Ether  type=IPv4 |<IP  ttl=2 dst=1.1.1.100 |>>,
    # <Ether  type=IPv4 |<IP  ttl=5 dst=1.1.1.100 |>>,
    # <Ether  type=IPv4 |<IP  ttl=6 dst=1.1.1.100 |>>,
    # <Ether  type=IPv4 |<IP  ttl=7 dst=1.1.1.100 |>>,
    # <Ether  type=IPv4 |<IP  ttl=8 dst=1.1.1.100 |>>,
    # <Ether  type=IPv4 |<IP  ttl=9 dst=1.1.1.100 |>>,
    # <Ether  type=IPv4 |<IP  ttl=1 dst=1.1.1.101 |>>,
    # <Ether  type=IPv4 |<IP  ttl=2 dst=1.1.1.101 |>>,
    # <Ether  type=IPv4 |<IP  ttl=5 dst=1.1.1.101 |>>,
    # <Ether  type=IPv4 |<IP  ttl=6 dst=1.1.1.101 |>>,
    # <Ether  type=IPv4 |<IP  ttl=7 dst=1.1.1.101 |>>,
    # <Ether  type=IPv4 |<IP  ttl=8 dst=1.1.1.101 |>>,
    # <Ether  type=IPv4 |<IP  ttl=9 dst=1.1.1.101 |>>,
    # <Ether  type=IPv4 |<IP  ttl=1 dst=1.1.1.102 |>>,
    # <Ether  type=IPv4 |<IP  ttl=2 dst=1.1.1.102 |>>,
    # <Ether  type=IPv4 |<IP  ttl=5 dst=1.1.1.102 |>>,
    # <Ether  type=IPv4 |<IP  ttl=6 dst=1.1.1.102 |>>,
    # <Ether  type=IPv4 |<IP  ttl=7 dst=1.1.1.102 |>>,
    # <Ether  type=IPv4 |<IP  ttl=8 dst=1.1.1.102 |>>,
    # <Ether  type=IPv4 |<IP  ttl=9 dst=1.1.1.102 |>>,
    # <Ether  type=IPv4 |<IP  ttl=1 dst=1.1.1.103 |>>,
    # <Ether  type=IPv4 |<IP  ttl=2 dst=1.1.1.103 |>>,
    # <Ether  type=IPv4 |<IP  ttl=5 dst=1.1.1.103 |>>,
    # <Ether  type=IPv4 |<IP  ttl=6 dst=1.1.1.103 |>>,
    # <Ether  type=IPv4 |<IP  ttl=7 dst=1.1.1.103 |>>,
    # <Ether  type=IPv4 |<IP  ttl=8 dst=1.1.1.103 |>>,
    # <Ether  type=IPv4 |<IP  ttl=9 dst=1.1.1.103 |>>]
    

.. note:: 以上举例并不代表用户的真实意图，用户需根据自己的实际需求进行报文构造。特别是当执行机上存在多个网卡时，需要根据实际情况对报文的源IP、源MAC等信息进行修改



抓包功能
~~~~~~~~~~~~~~~~~~~~

框架提供执行机网卡抓包功能，主要使用以下接口：

框架提供的方法 ``start_capture`` 用于启动抓包，成功开启抓包返回True，失败返回False，入参解释如下：

- ``filter`` 表示数据包的过滤器，用于过滤所需的数据包。可以是BPF过滤表达式，例如："tcp"、"udp"、"src host 192.168.1.1"等，用户不指定该入参时，抓取所有报文


框架提供的方法 ``stop_capture`` 用于停止抓包，返回值为抓包结果，用户获取返回值后可根据需求进一步处理，此接口无入参。

.. note:: 启停抓包必须成对使用


抓包接口使用示例如下：

.. code-block:: python
    :linenos:
    :emphasize-lines: 2,5,7

    # 引入库文件
    from scapy.all import *

    # 启动抓包，filter为tcp，表示只抓tcp的报文
    gl.PC.start_capture(filter='tcp')
    atf_wait('等待10s',10)
    capture_res = gl.PC.stop_capture()
    
    # 获取抓包个数
    length = len(capture_res)
    # 打印抓取报文IP报文头的version，用户可根据需要进行相应字段获取
    for pkt in capture_res:
        print(pkt[IP].version)


以下示例为举例不同的filter写法，举例不能穷尽，用户如果有新的需求请 **上网搜索**

.. code-block:: python
    :linenos:
    
    # 启动抓包，只抓除tcp报文以外的报文
    gl.PC.start_capture(filter="not tcp")

    # 启动抓包，只抓以太头源mac为00:11:22:33:44:55，IP报文头目的IP为192.168.0.1的报文
    gl.PC.start_capture(filter="ether src 00:11:22:33:44:55 and ip dst 192.168.0.1")
    
    # 启动抓包，只抓以太头源mac为00:11:22:33:44:55 或者 IP报文头目的IP为192.168.0.1的报文
    gl.PC.start_capture(filter="(ether src 00:11:22:33:44:55) or (ip dst 192.168.0.1)")
    
    # 启动抓包，只抓以太头源mac为00:11:22:33:44:55，IP报文头目的IP为192.168.0.1的报文或者tcp报文
    gl.PC.start_capture(filter="(ether src 00:11:22:33:44:55 and ip dst 192.168.0.1) or tcp")

    # 启动抓包，只抓以太头源mac为00:11:22:33:44:55，IP报文头目的IP为192.168.0.1，源IP为192.168.0.2的报文，或者tcp报文
    gl.PC.start_capture(filter="(ether src 00:11:22:33:44:55 and ip dst 192.168.0.1 and ip src 192.168.0.2) or tcp")

    # 启动抓包，只抓包长为128的报文
    gl.PC.start_capture(filter="len == 128")

    # 启动抓包，只抓包长大于等于128的报文
    gl.PC.start_capture(filter="greater 128")

    # 启动抓包，只抓包长小于等于128的报文
    gl.PC.start_capture(filter="less 128")


.. note:: 注意filter字符串是区分大小写的


-----------
PCServer类
-----------
PCServer包含众多子类型，常见的有 GeneralServer SimwareServer等（详见设备类型树）；该类需要先手工配置好各类辅助自动化的服务，如dns、ftp server、tftp server等；
框架在自动化执行过程，不会对该类型进行任何操作。


-----------------
ProgramServer类
-----------------
该类型可以看成在自动化测试中需要操作的主机，目前只支持LinuxServer，表示Linux系统，可以通过命令行进行操作。


发送命令
---------
通过发送命令行操作


.. code-block:: python
    :linenos:

    # 方法send第一参数为位置参数，为下发的命令行，不需要带回车
    # 参数search为提前返回标记
    # 参数timeout为最大等待时间，默认15s，通常与search联用
    # 参数nowait表示不等待命令行返回信息结束，默认为False

    # 向RHost窗口发送命令行，将返回信息赋值给res
    res = gl.RHost.send('ls', search=['#'], timeout=15, nowait=False)

    # 向RHost窗口发送命令行，不等待
    gl.RHost.send('tcpdump', nowait=True)
