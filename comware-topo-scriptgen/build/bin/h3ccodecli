#!/bin/bash
# ============================================
# H3C Code CLI 自动化工具 v3.6 (Linux版本)
# ============================================

# 设置脚本严格模式，兼容不同的shell版本
# 使用更可靠的方法检测当前shell类型
H3CCODERVERSION=V3.6
if [ -n "$BASH_VERSION" ]; then
    # 在bash中运行
    set -euo pipefail
else
    # 在非bash shell中运行（如dash）
    set -eu
fi
IFS=$'\n\t'

# ============================================
# 初始化用户信息和时间戳
# ============================================
echo ""
echo "[系统] 初始化环境信息..."

# 获取当前时间
TIME_STAMP="$(date +"%Y%m%d_%H%M%S")"
USERNAME_LINUX="$(whoami)"



# 格式化当前日期时间（用于显示）
CURRENT_DATETIME="$(date +"%Y-%m-%d %H:%M:%S")"

# 提取年月日时分秒
YYYY="$(date +"%Y")"
MM="$(date +"%m")"
DD="$(date +"%d")"
hh="$(date +"%H")"
nn="$(date +"%M")"
ss="$(date +"%S")"

echo "[用户] 当前用户: ${USERNAME_LINUX}"
echo "[时间] 执行时间: ${YYYY}-${MM}-${DD} ${hh}:${nn}:${ss}"
echo "[标识] 时间戳: ${TIME_STAMP}"

SESSION_FILE=".h3c_session"
# ============================================
# 从本地文件加载 SESSION_ID 和 PROJECT_ID
# ============================================
if [ -f "$SESSION_FILE" ]; then
    # 读取文件中的两个值
    source "$SESSION_FILE"
    echo "[系统] 检测到本地保存的会话信息..."
    echo "[项目] 项目标识: ${PROJECT_ID}"
    echo "[会话] SessionID: ${SESSION_ID}"
else
    # ============================================
    # 项目ID输入模块
    # ============================================
    echo ""
    echo "[项目ID] 请输入项目标识符..."
    echo "[提示] 项目类型请输入格式: NV202509090001 (NV+年月日+4位序号)"
    echo "[提示] 临时项目请输入格式: V9 (B75 B64 B70)"
    echo "[提示] 按回车键可取消输入"
    echo ""

    # 读取用户输入
    read -p "请输入项目ID: " PROJECT_ID

    # 检查是否取消输入
    if [ -z "${PROJECT_ID}" ]; then
        echo "[系统] 用户取消输入，程序退出"
        read -p "按回车键继续..." dummy
        exit 0
    fi

    # 验证项目ID格式
    ID_VALID=0
    ID_TYPE="unknown"
    

    # 检查是否为项目格式 (NV+12位数字)
    PROJECT_ID_CHECK="${PROJECT_ID}"
    if [ "${PROJECT_ID_CHECK:0:2}" = "NV" ]; then
        if [ ${#PROJECT_ID_CHECK} -eq 14 ]; then
            if [[ "${PROJECT_ID_CHECK:2}" =~ ^[0-9]+$ ]]; then
                ID_VALID=1
                ID_TYPE="project"
                echo "[验证] 项目ID格式正确: ${PROJECT_ID}"
            fi
        fi
    fi
    USERNAME_NUM="$(echo "$USERNAME_LINUX" | grep -o '[0-9]\+')"
    SESSION_ID="AI${USERNAME_NUM}$(date +"%Y%m%d%H%M%S")"
    # 检查是否为临时项目格式 (temp_+8位数字)
    if [ "${ID_VALID}" -eq 0 ]; then
        ID_VALID=1
        ID_TYPE="temporary"
        echo "[验证] 临时项目ID格式正确: ${PROJECT_ID}"
        PROJECT_ID=${PROJECT_ID}_${SESSION_ID}
    fi
    
    echo "[项目] 项目类型: ${ID_TYPE}"
    echo "[项目] 项目标识: ${PROJECT_ID}"
    echo ""
    echo "本次任务的 SessionID 为："
    echo "    ${SESSION_ID}"
    echo ""
    echo "目录下已经创建的 SessionID 标识文件，后续commit时请使用此标识"
    echo ""
    echo "请确认 SessionID 是否正确，然后按下 [回车] 继续..."

    # 等待用户回车确认
    read -s

    # 保存到文件
    echo "PROJECT_ID='${PROJECT_ID}'" > "$SESSION_FILE"
    echo "SESSION_ID='${SESSION_ID}'" >> "$SESSION_FILE"
    echo "[系统] 已保存会话信息到 ${SESSION_FILE}"
    # ============================================
    # 创建 SessionID 标识文件（如不存在）
    # ============================================
    if [ ! -f "${SESSION_ID}.txt" ]; then
        touch "${SESSION_ID}.txt"
        echo "已在当前目录创建标识文件: \"${SESSION_ID}.txt\""
    else
        echo "[系统] 标识文件 \"${SESSION_ID}.txt\" 已存在"
    fi
fi


# 配置文件路径
CONFIG_DIR="$HOME/project/.aigc_tool"
RUN_CONFIG="$CONFIG_DIR/aigc.json"
LOG_FILE="$CONFIG_DIR/aigc.log"

# 检查路径是否存在的函数
check_path_exists() {
    local path=$1
    if [ ! -e "$path" ]; then
        echo "[错误] 路径不存在: $path"
        return 1
    fi
    return 0
}

CREATE_ENV_PID=
# 首次运行配置
initial_setup() {
    echo "[系统] 首次运行配置..."
    
    # 创建配置目录
    mkdir -p "$CONFIG_DIR"
    
    # 初始化变量
    local topx_file=""
    local version_path=""
    local conftest_file=""
    local needReDeploy=0
    local device_type=""
    if [ -f "$RUN_CONFIG" ] ; then
            # 读取配置
        topx_file=$(jq -r '.topx_file' "$RUN_CONFIG")
        version_path=$(jq -r '.version_path' "$RUN_CONFIG")
        device_type=$(jq -r '.device_type // "simware9cen"' "$RUN_CONFIG")
        exec_ip=$(jq -r '.exec_ip' "$RUN_CONFIG")
        conftest_file=$(jq -r '.conftest_file' "$RUN_CONFIG")
        username=$(jq -r '.username' "$RUN_CONFIG")
        password=$(jq -r '.password' "$RUN_CONFIG")
                # 显示读取到的最终配置
        echo "[项目] topx文件:  ${topx_file:-未设置}"
        echo "[项目] conftest文件:  ${conftest_file:-未设置}"
        echo "[项目] 版本路径:  ${version_path:-未设置}"
        echo "[项目] 设备类型:  ${device_type:-未设置}"
        echo "[项目] 执行机IP:  ${exec_ip}"
        echo "[项目] 执行机远程登录账户:  ${username}"
        echo "[项目] 执行机远程登录密码:  ${password}"
        # 让用户确认
        read -r -p "请确认运行环境信息是否正确？(Y=正确, N=不正确重新输入): " choice
        case "$choice" in
            [Nn]*)
                needReDeploy=1
                ;;
            *)
                echo "[系统] 环境信息已确认，重新部署运行环境..."
                ;;
        esac
    fi
  
    if [[ ! -f "$RUN_CONFIG" || "${needReDeploy}" == "1" ]] ; then
        # 获取topx文件路径
        while true; do
            read -r -p "[输入] 请右键复制topx文件路径输入 (留空跳过部署环境): " topx_file
            if [ -z "$topx_file" ]; then
                echo "[信息] 跳过topx文件输入"
                return
            fi
            if check_path_exists "$topx_file"; then
                break
            fi
        done
        
        while true; do
            read -r -p "[输入] 请右键复制conftest文件路径输入 (必须输入): " conftest_file
            if [ -z "$conftest_file" ]; then
                echo "[信息] 跳过conftest文件输入, 运行环境无法配置"
                return
            fi
            if check_path_exists "$conftest_file"; then
                break
            fi
        done

        # 获取版本路径
        while true; do
            read -r -p "[输入] 请输入版本路径 (目前仅支持V9 simware qcow2 版本, 留空跳过部署环境): " version_path
            if [ -z "$version_path" ]; then
                echo "[信息] 跳过版本路径输入, 运行环境无法配置"
                return
            fi
            # 校验路径是否符合要求
            if [[ "$version_path" =~ ^\\\\10\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}.*simware9.* ]]; then
                break
            else
                echo "[错误] 版本路径格式不正确，请检查以下条件："
                echo "1. 必须以 \\\\10.xx.x.xxx 开头（IP 格式）"
                echo "2. 目前仅支持simware9"
                echo "3. 文件名必须是 qcow2 格式"
            fi
        done

        # 选择设备类型
        echo "[选择] 请选择设备类型："
        echo "  1) simware9cen (默认)"
        echo "  2) simware9dis"
        read -r -p "请输入数字 [1/2] (直接回车默认选1): " dev_choice

        case "${dev_choice:-1}" in
            1|simware9cen) device_type="simware9cen" ;;
            2|simware9dis) device_type="simware9dis" ;;
            *) 
                echo "[警告] 输入无效，使用默认设备类型 simware9cen"
                device_type="simware9cen"
                ;;
        esac

        echo "[信息] 已选择设备类型: $device_type"

        target_dir="/opt/coder/statistics/build/aigc_tool/${USERNAME_LINUX}"
        while true; do
            read -r -p "[输入] 如果依赖第三方库，请输入 (没有请留空跳过即可): " need_dir
            if [ -z "$need_dir" ]; then
                echo "[信息] 跳过依赖库输入"
                break
            fi
            if check_path_exists "$need_dir"; then
                cp -r "$need_dir" "${target_dir}"
                break
            fi
        done
    fi
    # 后台获取exec_ip
    echo "[系统] 正在后台获取执行机IP..."
    echo "[提示] 您可以在 $LOG_FILE 中查看进度和结果"
    version_path2=$(printf %s "$version_path" | sed 's/\\/\\\\/g')
    # 临时保存配置（不含exec_ip）
    echo "{
    \"topx_file\": \"$topx_file\",
    \"conftest_file\": \"$conftest_file\",
    \"version_path\": \"$version_path2\",
    \"device_type\": \"$device_type\",
    \"exec_ip\": \"待获取中...\",
    \"username\": \"itc\",
    \"password\": \"auto_123\"
}" > "$RUN_CONFIG"
    
    # 保证目录存在
    [ ! -d "/opt/coder/statistics/build/aigc_tool" ] && mkdir -p /opt/coder/statistics/build/aigc_tool

    # JSON 文件
    ALL_EXEC_IP_FILE="/opt/coder/statistics/build/aigc_tool/all_execIp_list.json"
    ALL_EXEC_IP_HISTORY_FILE="/opt/coder/statistics/build/aigc_tool/all_execIp_list_history.json"

    # 如果文件不存在，就初始化一个空数组
    if [ ! -f "$ALL_EXEC_IP_FILE" ]; then
        echo "[]" > "$ALL_EXEC_IP_FILE"
    fi

    if [ ! -f "$ALL_EXEC_IP_HISTORY_FILE" ]; then
        echo "[]" > "$ALL_EXEC_IP_HISTORY_FILE"
    fi

    # 获取当前用户名
    current_user=$(whoami)

    # 获取当前时间（格式：YYYY-MM-DD HH:MM:SS）
    current_time=$(date "+%Y-%m-%d %H:%M:%S")

    start_create_env() {
        if [ -d "/opt/coder/statistics/build/aigc_tool/${current_user}" ] ; then
            rm -rf /opt/coder/statistics/build/aigc_tool/${current_user}
            mkdir -p /opt/coder/statistics/build/aigc_tool/${current_user}
        else
            mkdir -p /opt/coder/statistics/build/aigc_tool/${current_user}
        fi
        cp  -f $topx_file /opt/coder/statistics/build/aigc_tool/${current_user}
        echo "$(date)--开始创建环境：--topofile "\\\\10.144.41.149\\webide\\aigc_tool\\${current_user}" --versionpath "${version_path}" --devicetype "${device_type}""  >> "$LOG_FILE"
        exec_ip=$(python ~/project/.aigc_tool/aigc_tool.py deploy \
            --topofile "\\\\10.144.41.149\\webide\\aigc_tool\\${current_user}" --versionpath "${version_path}" --devicetype "${device_type}" \
            | grep -oP "(?<='return_info': ')[^']+")
        echo "$(date)--创建环境结果: $exec_ip" >> "$LOG_FILE"
        if echo "$exec_ip" | grep -Eq '^([0-9]{1,3}\.){3}[0-9]{1,3}$'; then
          echo "$(date)--创建环境成功: 执行机IP: $exec_ip" >> "$LOG_FILE"
        else
           echo "$(date)--创建环境失败，请重新创建或者联系liuzhihui解决: $exec_ip"  >> "$LOG_FILE"
           return
        fi
        exec 200>/opt/coder/statistics/build/aigc_tool/all_execIp_list.lock
        flock 200
        # 更新运行配置
        jq --arg ip "$exec_ip" '.exec_ip = $ip' "$RUN_CONFIG" > "$RUN_CONFIG.tmp" \
            && mv "$RUN_CONFIG.tmp" "$RUN_CONFIG"
        # 追加到全局列表（带时间戳）
        jq --arg u "$current_user" --arg ip "$exec_ip" --arg t "$current_time" \
        '. += [{"user": $u, "ip": $ip, "time": $t}]' \
        "$ALL_EXEC_IP_FILE" > "$ALL_EXEC_IP_FILE.tmp" \
        && mv "$ALL_EXEC_IP_FILE.tmp" "$ALL_EXEC_IP_FILE"

        #保存历史使用数据
        jq --arg u "$current_user" --arg ip "$exec_ip" --arg t "$current_time" \
        '. += [{"user": $u, "ip": $ip, "time": $t}]' \
        "$ALL_EXEC_IP_HISTORY_FILE" > "$ALL_EXEC_IP_HISTORY_FILE.tmp" \
        && mv "$ALL_EXEC_IP_HISTORY_FILE.tmp" "$ALL_EXEC_IP_HISTORY_FILE"

        flock -u 200
    } 
    start_create_env &
    CREATE_ENV_PID=$!
    echo "$(date)--开始创建环境，PID:${CREATE_ENV_PID}" >> "$LOG_FILE"
    
    echo "[系统] 配置已初始化，IP获取任务已在后台运行"
    echo "[提示] 请稍后查看 $RUN_CONFIG 获取最终IP地址"
}


# 主逻辑
if [ -f "$RUN_CONFIG" ]; then
    echo "[系统] 检测到本地保存的运行环境信息..."
    
    # 读取配置
    topx_file=$(jq -r '.topx_file' "$RUN_CONFIG")
    version_path=$(jq -r '.version_path' "$RUN_CONFIG")
    device_type=$(jq -r '.device_type // "simware9cen"' "$RUN_CONFIG")
    exec_ip=$(jq -r '.exec_ip' "$RUN_CONFIG")
    conftest_file=$(jq -r '.conftest_file' "$RUN_CONFIG")
    username=$(jq -r '.username' "$RUN_CONFIG")
    password=$(jq -r '.password' "$RUN_CONFIG")
    
    if [[ "$exec_ip" == "待获取中..." ]]; then
        echo "$(date)--原配置环境未获取到IP，异常退出,等待ITC自动释放" >> "$LOG_FILE"
        echo "[系统] 进入初始化流程..."
        initial_setup
    else
        # 显示读取到的最终配置
        echo "[项目] topx文件:  ${topx_file:-未设置}"
        echo "[项目] conftest文件:  ${conftest_file:-未设置}"
        echo "[项目] 版本路径:  ${version_path:-未设置}"
        echo  "[项目] 设备类型:  ${device_type:-未设置}"
        echo "[项目] 执行机IP:  ${exec_ip}"
        echo "[项目] 执行机远程登录账户:  ${username}"
        echo "[项目] 执行机远程登录密码:  ${password}"

        # 让用户确认
        read -r -p "请确认运行环境信息是否正确？(Y=正确, N=不正确重新输入): " choice
        case "$choice" in
            [Nn]*)
                echo "$(date)--删除原配置环境: IP: $exec_ip " >> "$LOG_FILE"
                echo "[系统] 删除原有配置文件..."
                current_user=$(whoami)
                
                rm -rf /opt/coder/statistics/build/aigc_tool/${current_user}
                return_code=$(python ~/project/.aigc_tool/aigc_tool.py undeploy \
                | grep -oP "(?<='return_code': ')[^']+")
                if [ "${return_code}" == "200" ]; then
                    echo "$(date)--原配置删除成功: IP: $exec_ip " >> "$LOG_FILE"
                    delete_user=${current_user}
                    delete_ip=${exec_ip}
                    ALL_EXEC_IP_FILE="/opt/coder/statistics/build/aigc_tool/all_execIp_list.json"
                    exec 200>/opt/coder/statistics/build/aigc_tool/all_execIp_list.lock
                    flock 200
                    jq --arg u "$delete_user" --arg ip "$delete_ip" \
                    'del(.[] | select(.user == $u and .ip == $ip))' \
                    "$ALL_EXEC_IP_FILE" > "$ALL_EXEC_IP_FILE.tmp" && \
                    mv "$ALL_EXEC_IP_FILE.tmp" "$ALL_EXEC_IP_FILE"
                    flock -u 200
                else
                    echo "$(date)--原配置删除失败: IP: $exec_ip " >> "$LOG_FILE"
                fi
                rm -f "$RUN_CONFIG"
                echo "[系统] 进入初始化流程..."
                initial_setup
                ;;
            *)
                echo "[系统] 环境信息已确认，可继续执行后续步骤..."
                ;;
        esac
    fi

else
    initial_setup
fi

# 后续脚本逻辑可以在这里继续...
echo "[系统] 配置完成，继续执行后续操作..."


# ============================================
# 配置备份路径（Linux不使用网络驱动器映射）
# ============================================
echo ""
echo "[网络] 配置备份路径..."

# 在Linux系统中，我们直接使用路径而不是映射驱动器
# 假设/opt/build/AIGC是共享目录的挂载点
DEST_BASE="/opt/coder/statistics/build"
DEST_BEFORE="${DEST_BASE}/${USERNAME_LINUX}/${PROJECT_ID}/${TIME_STAMP}/before"
DEST_AFTER="${DEST_BASE}/${USERNAME_LINUX}/${PROJECT_ID}/${TIME_STAMP}/after"

# 确保备份目录存在
mkdir -p "${DEST_BEFORE}" "${DEST_AFTER}" 2>/dev/null || {
    echo "[错误] 无法创建备份目录，请确保对${DEST_BASE}有写权限"
    read -p "按回车键继续..." dummy
    exit 1
}

echo "[路径] 备份根目录: ${DEST_BASE}/${USERNAME_LINUX}/${PROJECT_ID}"
echo "[路径] 执行前备份: ${DEST_BEFORE}"
echo "[路径] 执行后备份: ${DEST_AFTER}"

# ============================================
# 项目路径配置
# ============================================
echo ""
echo "[项目] 配置项目路径..."

if [ $# -gt 0 ] && [ -n "$1" ]; then
    PROJECT_PATH="$1"
    echo "[项目] 使用指定路径作为项目路径"
else
    PROJECT_PATH="$(pwd)"
    echo "[项目] 使用当前目录作为项目路径"
fi

echo "[项目] 项目路径: ${PROJECT_PATH}"

# 切换到项目目录
if cd "${PROJECT_PATH}"; then
    echo "[项目] 成功切换到项目目录"
else
    echo "[错误] 无法访问项目路径: ${PROJECT_PATH}"
    echo "[错误] 请检查路径是否正确或是否有访问权限"
    read -p "按回车键继续..." dummy
    exit 1
fi

# ============================================
# Claude Projects 路径配置
# ============================================
echo ""
echo "[Claude] 配置Claude项目备份..."

CLAUDE_PROJECTS_BASE="${HOME}/.claude/projects"
echo "[Claude] Claude项目目录: ${CLAUDE_PROJECTS_BASE}"

# 规范化当前项目路径用于匹配
PROJECT_PATH_NORMALIZED="${PROJECT_PATH//:/_}"
PROJECT_PATH_NORMALIZED="${PROJECT_PATH_NORMALIZED//\//_}"
PROJECT_PATH_NORMALIZED="${PROJECT_PATH_NORMALIZED// /_}"
echo "[Claude] 标准化路径: ${PROJECT_PATH_NORMALIZED}"

# 查找匹配的项目目录
MATCHED_PROJECT_DIR=""
CLAUDE_BACKUP_ENABLED=0

if [ -d "${CLAUDE_PROJECTS_BASE}" ]; then
    echo "[Claude] 扫描现有Claude项目目录..."
    
    for dir in "${CLAUDE_PROJECTS_BASE}"/*; do
        if [ -d "${dir}" ]; then
            DIR_NAME="$(basename "${dir}")"
            # 移除目录名中的--和-进行标准化
            NORMALIZED_DIR="${DIR_NAME//--/}"
            NORMALIZED_DIR="${NORMALIZED_DIR//-/}"
            
            NORMALIZED_PATH_CHECK="${PROJECT_PATH_NORMALIZED//--/}"
            NORMALIZED_PATH_CHECK="${NORMALIZED_PATH_CHECK//-/}"
            NORMALIZED_PATH_CHECK="${NORMALIZED_PATH_CHECK//_/}"
            
            # 只进行完全匹配检查
            if [ "${NORMALIZED_DIR,,}" = "${NORMALIZED_PATH_CHECK,,}" ]; then
                MATCHED_PROJECT_DIR="${dir}"
                CLAUDE_BACKUP_ENABLED=1
                echo "[Claude] 精确匹配: ${dir}"
                break
            fi
        fi
    done
    
    if [ "${CLAUDE_BACKUP_ENABLED}" -eq 0 ]; then
        echo "[Claude] 暂未找到精确匹配的项目目录"
        MATCHED_PROJECT_DIR=""
    fi
else
    echo "[Claude] Claude项目目录不存在"
    CLAUDE_BACKUP_ENABLED=0
    MATCHED_PROJECT_DIR=""
fi

# 设置Claude备份目标目录
CLAUDE_BACKUP_DIR="${DEST_BASE}/${USERNAME_LINUX}/${PROJECT_ID}/${TIME_STAMP}/projects"
echo "[Claude] Claude备份目录: ${CLAUDE_BACKUP_DIR}"

if [ "${CLAUDE_BACKUP_ENABLED}" -eq 1 ]; then
    echo "[Claude] 模式：精确匹配监控 - ${MATCHED_PROJECT_DIR}"
else
    echo "[Claude] 模式：未找到匹配项目，将启动监控等待创建"
    CLAUDE_BACKUP_ENABLED=1
fi

# ============================================
# 代码备份模块 (执行前)
# ============================================
echo ""
echo "[备份] 开始备份执行前的Python代码..."
echo "[备份] 目标目录: ${DEST_BEFORE}"

# 确保备份目录存在
if [ ! -d "${DEST_BEFORE}" ]; then
    mkdir -p "${DEST_BEFORE}" 2>/dev/null
    if [ $? -eq 0 ]; then
        echo "[备份] 备份目录创建成功"
    else
        echo "[错误] 无法创建备份目录"
        read -p "按回车键继续..." dummy
        exit 1
    fi
fi

PY_COUNT=0
# 备份所有.py文件，排除conftest.py
find .  -type d \( -name ".venv" -o -name "test_example" \) -prune -o -type f -name "*.py" ! -name "conftest.py" ! -name "__init__.py" -print | while read -r py_file; do
    filename=$(basename "${py_file}")
        cp "${py_file}" "${DEST_BEFORE}" 2>/dev/null
        if [ $? -eq 0 ]; then
            PY_COUNT=$((PY_COUNT+1))
            if [ $PY_COUNT -lt 10 ]; then
                echo "[Python] 实时备份: ${py_file}"
            elif [ $PY_COUNT -eq 10 ]; then
                echo "...（更多文件备份中，确认工程路径是否正确）"
            fi
        fi
done


# ============================================
# AI模型配置和启动
# ============================================
echo ""
echo "[AI模型] 配置AI模型参数..."

export HTTPS_PROXY="http://172.22.0.29:8080"
export HTTP_PROXY="http://172.22.0.29:8080"
unset http_proxy https_proxy HTTP_PROXY HTTPS_PROXY

# 设置模型API配置
export ANTHROPIC_BASE_URL="http://10.144.41.149:4000/"

export ANTHROPIC_AUTH_TOKEN="xx"
#export ANTHROPIC_MODEL="deepseek-chat"
#export ANTHROPIC_SMALL_FAST_MODEL="deepseek-chat"
export DISABLE_AUTOUPDATER=1 
export BASH_MAX_TIMEOUT_MS=600000
#export CLAUDE_CODE_MAX_OUTPUT_TOKENS=50000
echo "[AI模型] API KEY: ${ANTHROPIC_AUTH_TOKEN}"
#echo "[AI模型] 模型类型: ${ANTHROPIC_MODEL}"
echo "[AI模型] API地址: ${ANTHROPIC_BASE_URL}"

# 启用遥测功能
export CLAUDE_CODE_ENABLE_TELEMETRY="1"
export OTEL_METRICS_EXPORTER="otlp,prometheus"
export OTEL_LOGS_EXPORTER="otlp"
export OTEL_EXPORTER_OTLP_PROTOCOL="grpc"
export OTEL_EXPORTER_OTLP_ENDPOINT="http://10.112.112.154:4317"
echo "[遥测] 遥测服务已启用"

# 调试配置：减少导出间隔
export OTEL_METRIC_EXPORT_INTERVAL="100000"
export OTEL_LOGS_EXPORT_INTERVAL="50000"
export CLAUDE_SESSION_START=$(date +%s)

# 配置 - 使用绝对路径
PYTHON_SCRIPT="${HOME}/.claude/hooks/add_aifinger_hook.py"
LOG_FILE2="${HOME}/.claude/hooks/add_aifinger_hook.log"

# 确保日志目录存在
LOG_DIR="$(dirname "$LOG_FILE2")"
mkdir -p "$LOG_DIR" 2>/dev/null || true

INTERVAL=180

# 检查 Python 脚本是否存在
if [ ! -f "$PYTHON_SCRIPT" ]; then
    echo "错误: Python 监控指纹脚本不存在: $PYTHON_SCRIPT" >&2
fi

# 启动定时任务
start_timer() {
    while true; do
        echo "执行 Python 监控指纹脚本 $(date)" >> "$LOG_FILE2"
        if ! python3 "$PYTHON_SCRIPT" >> "$LOG_FILE2" 2>&1; then
            echo "Python 监控指纹脚本执行失败 $(date)" >> "$LOG_FILE2"
        fi
        sleep "$INTERVAL"
    done
}

start_timer &
TIMER_PID=$!

# 清理函数
cleanup() {
    # 检查日志文件是否可写，如果不可写则使用标准输出
    if [ -w "$LOG_DIR" ] && touch "$LOG_FILE2" 2>/dev/null; then
        echo "清理定时任务 (PID: $TIMER_PID)..." >> "$LOG_FILE2"
        kill "$TIMER_PID" 2>/dev/null || true
        wait "$TIMER_PID" 2>/dev/null || true
        echo "定时任务已停止" >> "$LOG_FILE2"
    else
        echo "清理定时任务 (PID: $TIMER_PID)..."
        kill "$TIMER_PID" 2>/dev/null || true
        wait "$TIMER_PID" 2>/dev/null || true
        echo "定时任务已停止"
    fi
}

trap cleanup EXIT


echo ""
echo "==========================================="
echo "[启动] 正在启动H3C CODE CLI工具 版本: ${H3CCODERVERSION} "
echo "[提示] 请在CLI中输入您的需求"
echo "==========================================="
echo ""

# ============================================
# 启动Claude项目实时监控备份
# ============================================
# 创建监控脚本
MONITOR_PID=""
MONITOR_SCRIPT="/tmp/claude_monitor_${TIME_STAMP}.sh"

if [ "${CLAUDE_BACKUP_ENABLED}" -eq 1 ]; then
    echo "[Claude] 启动Claude项目实时备份..."
    
    # 创建Claude备份目录
    if [ ! -d "${CLAUDE_BACKUP_DIR}" ]; then
        mkdir -p "${CLAUDE_BACKUP_DIR}" 2>/dev/null
        if [ $? -eq 0 ]; then
            echo "[Claude] Claude备份目录创建成功: ${CLAUDE_BACKUP_DIR}"
        else
            echo "[警告] 无法创建Claude备份目录"
            CLAUDE_BACKUP_ENABLED=0
        fi
    fi
    
    if [ "${CLAUDE_BACKUP_ENABLED}" -eq 1 ]; then
        # 创建增强型实时监控脚本
        cat > "${MONITOR_SCRIPT}" << 'EOF'
#!/bin/bash
set -euo pipefail

CLAUDE_BASE_DIR="${1}"
BUP_DIR="${2}"
AFTER_DIR="${3}"
PROJECT_PATH="${4}"
TIME_STAMP="${5}"
PROJECT_ID="${6}"
BACKUP_MODE="${7}"
MATCHED_DIR="${8}"
DEST_BEFORE="${9}"

monitor_dir="${8}"
echo "[Claude] 监控器启动"
if [ -z "${monitor_dir}" ]; then
    echo "[Claude] 等待模式：监控整个Claude目录等待项目创建"
else
    echo "[Claude] 精确模式：监控目录 ${monitor_dir}"
fi

while true; do
    # 检查Claude项目目录中的jsonl文件
    if [ -z "${monitor_dir}" ]; then
        # 等待模式：扫描整个Claude目录寻找匹配项目
        if [ -d "${CLAUDE_BASE_DIR}" ]; then
            for dir in "${CLAUDE_BASE_DIR}"/*; do
                if [ -d "${dir}" ]; then
                    DIR_NAME="$(basename "${dir}")"
                    # 移除目录名中的--和-进行标准化
                    NORMALIZED_DIR="${DIR_NAME//--/}"
                    NORMALIZED_DIR="${NORMALIZED_DIR//-/}"
                    
                    # 标准化项目路径进行比较
                    PROJECT_PATH_NORM="${PROJECT_PATH//:/_}"
                    PROJECT_PATH_NORM="${PROJECT_PATH_NORM//\//_}"
                    PROJECT_PATH_NORM="${PROJECT_PATH_NORM// /_}"
                    PROJECT_PATH_NORM="${PROJECT_PATH_NORM//--/}"
                    PROJECT_PATH_NORM="${PROJECT_PATH_NORM//-/}"
                    
                    # 只进行完全匹配检查
                    if [ "${NORMALIZED_DIR,,}" = "${PROJECT_PATH_NORM,,}" ]; then
                        echo "[Claude] 发现新创建的匹配项目: ${dir}"
                        monitor_dir="${dir}"
                        break
                    fi
                fi
            done
        fi
    else
        # 精确模式：直接检查已知目录
        if [ -d "${monitor_dir}" ]; then
            for file in "${monitor_dir}"/*.jsonl; do
                if [ -f "${file}" ]; then
                    # 获取文件完整路径
                    file_path="${file}"
                    
                    # 计算与当前时间差（秒）
                    file_time="$(stat -c %Y "${file_path}")"
                    current_time="$(date +%s)"
                    sec_diff=$((current_time - file_time))
                    
                    # 取绝对值
                    if [ ${sec_diff} -lt 0 ]; then
                        sec_diff=$((sec_diff * -1))
                    fi
                    
                    # 判断是否在10秒以内
                    if [ ${sec_diff} -le 10 ]; then
                        cp "${file}" "${BUP_DIR}" 2>/dev/null
                        if [ $? -eq 0 ]; then
                            echo "[Claude] 备份成功: $(basename "${file}")"
                        else
                            echo "[Claude] 备份失败: $(basename "${file}")"
                        fi
                    else
                        echo "[Claude] 跳过备份: $(basename "${file}")"
                    fi
                fi
            done
        fi
    fi
    
    # 如果找到了匹配目录，备份其中的jsonl文件
    if [ -n "${monitor_dir}" ] && [ -d "${monitor_dir}" ]; then
        for file in "${monitor_dir}"/*.jsonl; do
            if [ -f "${file}" ]; then
                file_name="$(basename "${file}")"
                if [ ! -f "${BUP_DIR}/${file_name}" ]; then
                    echo "[Claude] 发现新会话文件: ${file_name}"
                    
                    # 计算与当前时间差（秒）
                    file_time="$(stat -c %Y "${file}")"
                    current_time="$(date +%s)"
                    sec_diff=$((current_time - file_time))
                    
                    # 取绝对值
                    if [ ${sec_diff} -lt 0 ]; then
                        sec_diff=$((sec_diff * -1))
                    fi
                    
                    # 判断是否在10秒以内
                    if [ ${sec_diff} -le 300 ]; then
                        cp "${file}" "${BUP_DIR}" 2>/dev/null
                        if [ $? -eq 0 ]; then
                            echo "[Claude] 备份成功: ${file_name}"
                        else
                            echo "[Claude] 备份失败: ${file_name}"
                        fi
                    else
                        echo "[Claude] 跳过备份: ${file_name}"
                    fi
                fi
            fi
        done
    fi
    
    # 同时备份after目录中的Python文件
    if [ -d "${PROJECT_PATH}" ]; then
        cd "${PROJECT_PATH}" || exit 1
        mkdir -p "${AFTER_DIR}" 2>/dev/null
        if [ -d "${AFTER_DIR}" ]; then
            find .  -type d \( -name ".venv" -o -name "test_example" \) -prune -o -type f -name "*.py" ! -name "conftest.py" ! -name "__init__.py" -print | while read -r py_file; do
                filename=$(basename "${py_file}")
                before_file="${DEST_BEFORE}/${filename}"
                after_file="${AFTER_DIR}/${filename}"
               
                if [ -f "${before_file}" ]; then
                    # 计算 before 和 after 文件的 MD5
                    md5_before=$(md5sum "${before_file}" | awk '{print $1}')
                    md5_after=$(md5sum "${py_file}" | awk '{print $1}')
                    echo ${before_file}  ${py_file}  ${md5_before} ${md5_after}
                    if [ "${md5_before}" = "${md5_after}" ]; then
                        continue
                    fi

                fi

                if [ -f "${after_file}" ]; then
                    md5_after_back=$(md5sum "${after_file}" | awk '{print $1}')
                    md5_after=$(md5sum "${py_file}" | awk '{print $1}')
                    if [ "${md5_after_back}" = "${md5_after}" ]; then
                        continue
                    fi
                fi
                cp "${py_file}" "${AFTER_DIR}" 2>/dev/null
                if [ $? -eq 0 ]; then
                    echo "[Python] 实时备份: ${py_file}"
                fi
            done
        fi
    fi
    # 等待10秒后继续监控
    sleep 5
done
EOF
        
        # 设置监控脚本为可执行
        chmod +x "${MONITOR_SCRIPT}"
        
        echo "[Claude] 增强型后台监控脚本已创建: ${MONITOR_SCRIPT}"
        
        # 启动后台监控任务
        bash "${MONITOR_SCRIPT}" "${CLAUDE_PROJECTS_BASE}" "${CLAUDE_BACKUP_DIR}" "${DEST_AFTER}" "${PROJECT_PATH}" "${TIME_STAMP}" "${PROJECT_ID}" "${CLAUDE_BACKUP_ENABLED}" "${MATCHED_PROJECT_DIR}" "${DEST_BEFORE}" > /dev/null 2>&1 &
        MONITOR_PID=$!
        
        echo "[Claude] 增强型后台监控任务已启动（PID: ${MONITOR_PID}）"
        
        if [ -z "${MATCHED_PROJECT_DIR}" ]; then
            echo "[Claude] 监控模式：等待模式 - 动态检测项目创建"
        else
            echo "[Claude] 监控模式：精确匹配 - ${MATCHED_PROJECT_DIR}"
        fi
    fi
else
    echo "[Claude] 跳过Claude项目监控（初始化失败）"
fi

# 启动Claude CLI (阻塞执行)
claude --allowedTools "Bash,Read" --permission-mode acceptEdits --dangerously-skip-permissions

# ============================================
# 代码备份模块 (执行后)
# ============================================
echo ""
echo "[备份] 开始备份执行后的Python代码..."
echo "[备份] 目标目录: ${DEST_AFTER}"

if [ ! -d "${DEST_AFTER}" ]; then
    mkdir -p "${DEST_AFTER}" 2>/dev/null
    if [ $? -eq 0 ]; then
        echo "[备份] 备份目录创建成功"
    else
        echo "[错误] 无法创建备份目录"
        read -p "按回车键继续..." dummy
        exit 1
    fi
fi

PY_COUNT_AFTER=0
# 复制时排除 conftest.py
find .  -type d \( -name ".venv" -o -name "test_example" \) -prune -o -type f -name "*.py" ! -name "conftest.py" ! -name "__init__.py" -print | while read -r py_file; do
    filename=$(basename "${py_file}")
    before_file="${DEST_BEFORE}/${filename}"
    after_file="${DEST_AFTER}/${filename}"
    if [ -f "${before_file}" ]; then
        # 计算 before 和 after 文件的 MD5
        md5_before=$(md5sum "${before_file}" | awk '{print $1}')
        md5_after=$(md5sum "${py_file}" | awk '{print $1}')

        if [ "${md5_before}" = "${md5_after}" ]; then
            #echo "[跳过] ${filename} 与 before 相同, 删除 before 文件"
            rm -f "${before_file}"
            rm -f "${after_file}"
            continue
        fi
    fi
    if [ -f "${after_file}" ]; then
         md5_after_back=$(md5sum "${after_file}" | awk '{print $1}')
         md5_after=$(md5sum "${py_file}" | awk '{print $1}')
          if [ "${md5_after_back}" = "${md5_after}" ]; then
           continue
          fi
    fi

    cp "${py_file}" "${DEST_AFTER}" 2>/dev/null
    if [ $? -eq 0 ]; then
        PY_COUNT_AFTER=$((PY_COUNT_AFTER+1))
        echo "[Python] 实时备份: ${py_file}"
    fi
done


# ============================================
# 清理和退出
# ============================================
echo ""
echo "[清理] 正在清理资源..."

# 停止Claude监控任务
if [ "${CLAUDE_BACKUP_ENABLED}" -eq 1 ] && [ -n "${MONITOR_PID}" ]; then
    echo "[Claude] 停止Claude监控任务..."
    # 优雅停止监控脚本
    kill -TERM "${MONITOR_PID}" || {
        # 如果优雅停止失败，强制杀死
        kill -KILL "${MONITOR_PID}"
    }
    
    # 等待进程结束
    wait "${MONITOR_PID}" 2>/dev/null || true
    
    # 删除临时监控脚本
    if [ -f "${MONITOR_SCRIPT}" ]; then
        rm "${MONITOR_SCRIPT}" 2>/dev/null
        echo "[Claude] 临时监控脚本已清理"
    fi
    
    # 最后一次备份检查 - 支持动态发现项目
    echo "[Claude] 执行最后一次备份检查..."
    
    # 如果最初没有匹配项目，尝试重新查找
    if [ -z "${MATCHED_PROJECT_DIR}" ]; then
        echo "[Claude] 重新扫描Claude项目目录寻找新创建的项目..."
        
        if [ -d "${CLAUDE_PROJECTS_BASE}" ]; then
            for dir in "${CLAUDE_PROJECTS_BASE}"/*; do
                if [ -d "${dir}" ]; then
                    DIR_NAME="$(basename "${dir}")"
                    NORMALIZED_DIR="${DIR_NAME//--/}"
                    NORMALIZED_DIR="${NORMALIZED_DIR//-/}"
                    NORMALIZED_PATH_CHECK="${PROJECT_PATH_NORMALIZED//--/}"
                    NORMALIZED_PATH_CHECK="${NORMALIZED_PATH_CHECK//-/}"
                    
                    if [ "${NORMALIZED_DIR,,}" = "${NORMALIZED_PATH_CHECK,,}" ]; then
                        echo "[Claude] 发现新创建的匹配项目: ${dir}"
                        MATCHED_PROJECT_DIR="${dir}"
                        break
                    fi
                fi
            done
        fi
    fi
    
    if [ -n "${MATCHED_PROJECT_DIR}" ] && [ -d "${MATCHED_PROJECT_DIR}" ]; then
        echo "[Claude] 检查项目目录: ${MATCHED_PROJECT_DIR}"
        echo "[Claude] 检查备份目录中的jsonl文件..."
        
        # 遍历备份目录中的jsonl文件，只备份本地存在的同名文件
        for backup_file in "${CLAUDE_BACKUP_DIR}"/*.jsonl; do
            if [ -f "${backup_file}" ]; then
                backup_file_name="$(basename "${backup_file}")"
                local_file_path="${MATCHED_PROJECT_DIR}/${backup_file_name}"
                
                # 检查本地是否存在同名文件
                if [ -f "${local_file_path}" ]; then
                    # 直接备份本地文件
                    cp "${local_file_path}" "${CLAUDE_BACKUP_DIR}" 2>/dev/null
                    if [ $? -eq 0 ]; then
                        echo "[Claude] 最终备份: ${backup_file_name}"
                    else
                        echo "[Claude] 最终备份失败: ${backup_file_name}"
                    fi
                else
                    echo "[Claude] 本地不存在文件: ${backup_file_name}"
                fi
            fi
        done
    else
        echo "[Claude] 未发现匹配的Claude项目目录"
    fi
    
    echo "[Claude] 当前项目Claude备份完成"
fi

# 恢复原始工作目录
echo "[清理] 恢复原始工作目录"

echo "执行 Python 监控指纹脚本 $(date)" >> "$LOG_FILE2"
if ! python3 "$PYTHON_SCRIPT" >> "$LOG_FILE2" 2>&1; then
    echo "Python 监控指纹脚本执行失败 $(date)" >> "$LOG_FILE2"
fi
echo "!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
echo "[系统]环境资源正在申请请勿退出..."
echo "!!!!!!!!!!!!!!!!!!!!!!!!!!!!"

if [ -n "$CREATE_ENV_PID" ] ; then
    wait "$CREATE_ENV_PID" 
fi 
# 让用户确认
if [ -f "$RUN_CONFIG" ]; then
    exec_ip=$(jq -r '.exec_ip' "$RUN_CONFIG")
    if [[ "$exec_ip" != "待获取中..." ]]; then
        read -r -p "请确认运行环境信息是否释放？(Y=释放, N=不释放重新输入): " choice
        case "$choice" in
            [Yy]*)
                echo "[系统] 释放环境资源..."
                
                current_user=$(whoami)
                echo "$(date)--用户主动释放资源 : ${exec_ip} " >> $LOG_FILE
                

                
                rm -rf /opt/coder/statistics/build/aigc_tool/${current_user}
                return_code=$(python ~/project/.aigc_tool/aigc_tool.py undeploy | grep -oP "(?<='return_code': ')[^']+")
                echo =========${return_code}
                # 更新运行配置
                if [ "${return_code}" == "200" ]; then
                    delete_user=${current_user}
                    delete_ip=${exec_ip}
                    ALL_EXEC_IP_FILE="/opt/coder/statistics/build/aigc_tool/all_execIp_list.json"
                    exec 200>/opt/coder/statistics/build/aigc_tool/all_execIp_list.lock
                    flock 200
                    jq --arg u "$delete_user" --arg ip "$delete_ip" \
                    'del(.[] | select(.user == $u and .ip == $ip))' \
                    "$ALL_EXEC_IP_FILE" > "$ALL_EXEC_IP_FILE.tmp" && \
                    mv "$ALL_EXEC_IP_FILE.tmp" "$ALL_EXEC_IP_FILE"
                    flock -u 200
                fi
                exec_ip="待获取中..."
                jq --arg ip "$exec_ip" '.exec_ip = $ip' "$RUN_CONFIG" > "$RUN_CONFIG.tmp" \
                    && mv "$RUN_CONFIG.tmp" "$RUN_CONFIG"
                ;;
            *)
                echo "[系统] 环境信息已确认，可继续执行后续步骤..."
                ;;
        esac
    fi
fi

# ============================================
# 完成信息
# ============================================
echo ""
echo "==========================================="
echo "[完成] H3C Code CLI ${H3CCODERVERSION} 执行完毕"
echo "[时间] 结束时间: $(date +"%Y-%m-%d %H:%M:%S")"
echo "==========================================="
echo ""

# 退出脚本
exit 0
