.. _topics-常用方法:


常用方法
===========

----------------
atf_wait
----------------
一些脚本中要求有固定的等待，为了将等待时间的操作记录到脚本日志，推荐使用 ``atf_wait`` 方法。

.. code-block:: python
    :linenos:

    # 等待 5 s
    atf_wait('固定等待', 5)

    # 等待500 ms
    atf_wait('固定等待', 0.5)


``atf_wait`` 方法支持的参数如下：
  - ``msg``: 等待原因描述
  - ``wait``: 等待时间，单位为 **s**


----------------
atf_logs
----------------
在脚本中，有时会记录一些信息到脚本日志中（比如检查失败的信息记录），推荐使用 ``atf_logs`` 方法。

.. code-block:: python
    :linenos:

    # 脚本记录
    atf_logs(f'脚本记录', 'warn')

``atf_logs`` 方法支持的参数如下：
  - ``msg``: 记录的信息
  - ``level``: 记录级别，支持 ``info`` ``warn`` ``error`` 三个级别，默认为 ``info``



----------------
atf_setting
----------------
``atf_setting`` 用于设置一些框架参数，以适应某些特殊场景，目前提供的功能如下：


1、在脚本执行过程中，框架会自动向设备下发此时执行的脚本名称及步骤名称，如果此时设备处于bootware模式，会导致出错，此时需要在conftest.py文件中的setup方法中使用 ``atf_setting`` 关闭自动下发。

.. code-block:: python
    :linenos:

    # conftest.py
    
    # 不能删除setup/teardown的装饰器
    @atf_time_stats("ATFSetupTime")
    @atf_adornment
    def setup():
        atf_setting(ignore_send_flag=True)


2、有些设备响应较慢，命令行下发时间默认的15s不够，可以使用 ``atf_setting`` 设置命令行最大等待时间。 **设置后对后续所有脚本生效**

.. code-block:: python
    :linenos:

    # conftest.py or 脚本的步骤
    
    # 设置comware设备命令行最大等待时间，单位s
    atf_setting(cmd_timeout=30)

    # 恢复comware设备命令行最大等待时间
    atf_setting(cmd_timeout=None)


-------------------
Comware设备类方法
-------------------

getTableValue
----------------
在网络设备自动化测试中，有时需要在命令行回显提到某些信息，命令行回显信息含有表格格式的信息，此时可以使用 ``getTableValue`` 方法，其功能为：向设备下发命令行或获取屏幕信息，在回显通过用户指定关键字返回表格值

观察如下信息

::

    Brief information on interfaces in route mode:
    Link: ADM - administratively down; Stby - standby
    Protocol: (s) - spoofing
    Interface            Link Protocol Primary IP        Description              
    InLoop0              UP   UP(s)    --                
    MGE0/0/0             ADM  DOWN     --                
    NULL0                UP   UP(s)    --                
    REG0                 UP   --       --                
    Vlan101              DOWN DOWN     11.215.247.2      
    Vlan102              UP   UP       140.163.227.4     
    Vlan105              DOWN DOWN     195.117.133.9     

    Brief information on interfaces in bridge mode:
    Link: ADM - administratively down; Stby - standby
    Speed: (a) - auto
    Duplex: (a)/A - auto; H - half; F - full
    Type: A - access; T - trunk; H - hybrid
    Interface            Link Speed     Duplex Type PVID Description              
    XGE10/0/1            ADM  auto      A      A    1    [aaa]ertyuifdkbaurbgiaugb
    XGE10/0/2            ADM  auto      A      A    1    
    XGE10/0/3            ADM  auto      A      A    1    
    XGE10/0/4            ADM  auto      A      A    1    
    XGE10/0/5            ADM  auto      A      A    1    
    XGE10/0/6            ADM  auto      A      A    1    
    XGE10/0/7            ADM  auto      A      A    1    
    XGE10/0/8            ADM  auto      A      A    1    
    XGE10/0/9            DOWN auto      A      A    101  
    XGE10/0/10           ADM  auto      A      A    1    
    XGE10/0/11           ADM  auto      A      A    1    
    XGE10/0/12           ADM  auto      A      A    1    
    XGE10/0/13           UP   10G(a)    F(a)   A    102  
    XGE10/0/14           DOWN auto      A      A    105  
    XGE10/0/15           ADM  auto      A      A    1    
    XGE10/0/16           ADM  auto      A      A    1    


提取表格信息示例

.. code-block:: python
    :linenos:

    # 提取表头中包含['Interface','Protocol','Primary IP']，列名为 Interface 、Protocol 、Primary IP的列
    # res的值为：{'Interface': ['InLoop0', 'MGE0/0/0', 'NULL0', 'REG0', 'Vlan101', 'Vlan102', 'Vlan105'], 'Protocol': ['UP(s)', 'DOWN', 'UP(s)', '--', 'DOWN', 'UP', 'DOWN'], 'Primary IP': ['--', '--', '--', '--', '11.215.247.2', '140.163.227.4', '195.117.133.9']}
    res = gl.dut1.getTableValue(cmd=f'display interface brief',
                                table_header = ['Interface','Protocol','Primary IP'],
                                collumns = ['Interface','Protocol','Primary IP'])

    # 提取表头中包含['Interface','Protocol','Primary IP']，列名为 Protocol 和 Primary IP，行名为Vlan105，行名所在的列名为Interface的值
    # res的值为['DOWN', '195.117.133.9']
    res = gl.dut1.getTableValue(cmd=f'display interface brief',
                                table_header = ['Interface','Protocol','Primary IP'],
                                collumns = ['Protocol','Primary IP'],
                                rows = ['Vlan105','Interface'])

    # 提取表头中包含['Interface','Protocol','Primary IP']，列名为 Primary IP，行名为Vlan105的值
    # res的值为'195.117.133.9'
    res = gl.dut1.getTableValue(cmd=f'display interface brief',
                                table_header = ['Interface','Protocol','Primary IP'],
                                collumns = 'Primary IP',
                                rows = 'Vlan105')
    
    # 提取表头中包含"Interface            Link Protocol"，表格中所有值
    # 注意采用如下方式传入table_header无法正确获取Primary IP的值，如果需要获取类似 Primary IP 的值，需要用上述示例进行table_header传参，将 Primary IP 以列表元素的方式传入
    # res的值为defaultdict(<class 'list'>, {'Interface': ['InLoop0', 'MGE0/0/0', 'NULL0', 'REG0', 'Vlan101', 'Vlan102', 'Vlan105'], 'Link': ['UP', 'ADM', 'UP', 'UP', 'DOWN', 'UP', 'DOWN'], 'Protocol': ['UP(s)', 'DOWN', 'UP(s)', '--', 'DOWN', 'UP', 'DOWN'], 'Primary': ['--', '--', '--', '--', '11.215.2', '140.163.', '195.117.'], 'IP': ['', '', '', '', '47.2', '227.4', '133.9'], 'Description': ['', '', '', '', '', '', '']})
    res = gl.dut1.getTableValue(cmd=f'display interface brief',
                                table_header = f"Interface            Link Protocol")
    # 后续对表格值的获取，用户根据需要自行获取
    # 举例：获取第1行中列名为Protocol的值
    a = res['Protocol'][1]
    # 举例：获取列名为Protocol，行名为Interface列中Vlan105对应的值
    b = res["Protocol"][res['Interface'].index("Vlan105")]

观察如下信息，提取等价路由信息，对于表格值类似等价路由信息获取，需要用户获取完成后再对结果进行进一步处理

::

    Destinations : 10        Routes : 10
    
    Destination/Mask    Proto  Pre  Cost         NextHop         Interface
    0.0.0.0/32          Direct 0    0            127.0.0.1       InLoop0
    1.1.1.0/24          Static 60   0            192.168.47.4    GE1/0/1
                        Static 60   0            192.168.47.4    GE1/0/2
    127.0.0.0/8         Direct 0    0            127.0.0.1       InLoop0
    127.0.0.0/32        Direct 0    0            127.0.0.1       InLoop0
    127.0.0.1/32        Direct 0    0            127.0.0.1       InLoop0
    127.255.255.255/32  Direct 0    0            127.0.0.1       InLoop0
    192.168.1.40/32     Direct 0    0            127.0.0.1       InLoop0
    224.0.0.0/4         Direct 0    0            0.0.0.0         NULL0
    224.0.0.0/24        Direct 0    0            0.0.0.0         NULL0
    255.255.255.255/32  Direct 0    0            127.0.0.1       InLoop0

提取表格信息示例

.. code-block:: python
    :linenos:

    # 提取表头中包含['Destination/Mask', 'Proto']，列名为 NextHop 和 Interface 的列
    # res的值为：{'nexthop': ['127.0.0.1', ['192.168.47.4', '192.168.47.4'], '127.0.0.1', '127.0.0.1', '127.0.0.1', '127.0.0.1', '127.0.0.1', '0.0.0.0', '0.0.0.0', '127.0.0.1'], 'interface': ['inloop0', ['ge1/0/1', 'ge1/0/2'], 'inloop0', 'inloop0', 'inloop0', 'inloop0', 'inloop0', 'null0', 'null0', 'inloop0']}
    res = gl.dut1.getTableValue(cmd=f'display ip routing-table',
                                table_header=['Destination/Mask', 'Proto'],
                                collumns=['NextHop', 'Interface'])

    # 提取表头中包含['Destination/Mask', 'Proto']，列名为 NextHop 和 Interface ，行名为 1.1.1.0/24 ，行名所在的列名为 Destination/Mask 的值
    # res的值为[['192.168.47.4', '192.168.47.4'], ['ge1/0/1', 'ge1/0/2']]
    res = gl.dut1.getTableValue(cmd=f'display ip routing-table',
                                table_header=['Destination/Mask', 'Proto'],
                                collumns=['NextHop', 'Interface'],
                                rows=['1.1.1.0/24','Destination/Mask'])

    # 提取表头中包含['Destination/Mask', 'Proto']，列名为 NextHop 和 Interface ，行名为 1.1.1.0/24 的值
    # res的值为[['192.168.47.4', '192.168.47.4'], ['ge1/0/1', 'ge1/0/2']]
    res = gl.dut1.getTableValue(cmd=f'display ip routing-table',
                                table_header=['Destination/Mask', 'Proto'],
                                collumns=['NextHop', 'Interface'],
                                rows='1.1.1.0/24')

    # 提取表头中包含['Destination/Mask', 'Proto']，列名为 NextHop 和 Interface ，行名为 1.1.1.0/24 的值，区分大小写
    # res的值为[['192.168.47.4', '192.168.47.4'], ['GE1/0/1', 'GE1/0/2']]
    res = gl.dut1.getTableValue(cmd=f'display ip routing-table',
                                table_header=['Destination/Mask', 'Proto'],
                                collumns=['NextHop', 'Interface'],
                                rows='1.1.1.0/24',
                                is_strict=True)

    # 后续对表格值的获取，用户根据需要自行获取
    # 获取出接口为GE1/0/2的nexthop值，以上述最后一条获取结果举例
    next_hop_list = res[0]
    out_interface_list = res[1]
    index = out_interface_list.index("GE1/0/2")
    next_hop = next_hop_list[index]
    print(next_hop)


当表格的列名右对齐时，如果列内容长度大于列名长度，会导致只能获取列内容的部分，此时需要使用 ``%`` 点位符，目前只支持左起占位符。

::

    VPN instance: 1
    BGP local router ID: 112.1.1.1
    Total number of peers: 2                 Peers in established state: 0
    
    Peer                    AS  MsgRcvd  MsgSent OutQ PrefRcv Up/Down  State

    112.1.1.1              100        0        0    0       0 00:00:06 Established
    112.1.1.2              200        0        0    0       0 00:00:06 Established

提取表格信息示例

.. code-block:: python
    :linenos:

    # 提取表头中包含['Peer', 'AS']，列名为 Peer 和 AS 的列，由于AS是右对齐列，100的长度大AS的长度，此时要添加%点位符，%占位符的数量要根据AS的值的长度做调整
    # 如果添加了%占位符，table_header、collumns两个参数都要中指定的列名都要添加
    # res的值为：{'Peer': ['112.1.1.1', '112.1.1.2'], '%AS': ['100', '100']}
    res = dut1.getTableValue(cmd='display bgp peer ipv4',
                                 table_header = ['Peer','%AS'],
                                 collumns = ['Peer','%AS'],
                                 is_strict=True)


getTableValue方法参数如下：
    - ``cmd`` ：命令行或get_buffer，必选参数，类型为字符串或get_buffer方法，必选参数
    - ``timeout``： 等待回显的最大时间，单位为秒，可选参数，整型，默认值为15秒。只有当回显时间特别长时，才需要设置。当cmd为get_buffer方法时不生效
    - ``table_header`` ：表头，支持字符串和列表类型，推荐使用 **列表** 类型， **注意当表头中列名包含空格时，需要在列表中传入**，如示例中的Primary IP，必选参数
    - ``collumns`` ：用户期望取得列名下面的值，支持字符串和列表形式传入列名，当期望取多个列时，列表形式传入
    - ``rows`` ：用户期望取得行名下面的值，支持字符串和列表形式，传入行名，列表最多只支持两个元素，第一个元素为行名，第二个元素为行名所在的列名，当rows为字符串，或rows为列表但列表只有一个元素时，默认指代行名为第一列，如果传入行名不在第一列中，请用户将该行名所在的列名作为第二个元素传入rows中
    - ``is_strict``： 是否区分大小写，默认为False不区分大小写


.. admonition:: Note

    1) rows变量的使用需与collumns共同使用，即不支持rows有值但collumns为空; 
    
    2) rows只支持取一行值，不支持同时取多行值
    
    3) 如果用户需要同时取多行多列对应值，建议不设置collumns和rows，当前接口会返回一个字典，字典键为列名，字典值为当前列的所有取值，用户在脚本中再自行处理

    4) 表头 table_header 的指定需要按照实际表头的顺序进行指定，表头中包含 **空格** 列名，必须在变量 table_header 列表中传入
    
    5) 接口默认传回的信息都是小写，如果用户需要保持表格中的大小写，需要在调用 getTableValue 接口时传入 **is_strict=True** 变量



getStringValue
----------------
在网络设备自动化测试中，有时需要在命令行回显提到某些信息，此时可以使用 ``getStringValue`` 方法，其功能为：向设备下发命令行并获取屏幕信息，在回显通过正则表达式对关键字进行匹配，以指定类型返回满足条件的值

支持如下格式：
    - ``keyword is value`` 在期望字符串的右侧取值，取冒号后面的值到行尾或遇到标点符号
    - ``keyword : value`` 在期望字符串的右侧取值，取冒号后面的值到行尾或遇到标点符号
    - ``keyword value`` 在期望字符串的右侧取值，到行尾或遇到标点符号
    - ``value keyword`` 在期望字符串的左侧取值，到行尾或遇到标点符号


观察如下信息

::

    GigabitEthernet0/1
    Current state: UP
    Line protocol state: UP
    Description: GigabitEthernet0/1 Interface
    Bandwidth: 1000000kbps
    Maximum Transmit Unit: 1500
    Internet Address is 11.91.255.73/24 Primary
    IP Packet Frame Type:PKTFMT_ETHNT_2, Hardware Address: 50da-0045-fed0
    IPv6 Packet Frame Type:PKTFMT_ETHNT_2, Hardware Address: 50da-0045-fed0
    Media type: twisted pair, loopback: not set, promiscuous mode: not set
    1000Mb/s, Full-duplex, link type: autonegotiation
    flow-control: disabled
    Output queue - Urgent queuing: Size/Length/Discards 0/100/0
    Output queue - Protocol queuing: Size/Length/Discards 0/500/0
    Output queue - FIFO queuing: Size/Length/Discards 0/75/0
    Last link flapping: 2 weeks 4 days 20 hours 57 minutes
    Last clearing of counters: Never
    Last 300 seconds input:  28 packets/sec 1742 bytes/sec 0%
    Last 300 seconds output:  33 packets/sec 2077 bytes/sec 0%
    Input (total):  17866027 packets, 1091923161 bytes
            - unicasts, - broadcasts, - multicasts, - pauses
    Input (normal):  17866027 packets, - bytes
            15535782 unicasts, 291826 broadcasts, 2038419 multicasts, 0 pauses
    Input:  0 input errors, 0 runts, 0 giants, - throttles
            0 CRC, - frame, - overruns, 0 aborts
            - ignored, - parity errors
    Output (total): 18381209 packets, 1179145599 bytes
            - unicasts, - broadcasts, - multicasts, - pauses
    Output (normal): 18381209 packets, - bytes
            18381205 unicasts, 4 broadcasts, 0 multicasts, 0 pauses
    Output: 0 output errors, - underruns, - buffer failures
            0 aborts, 0 deferred, 0 collisions, 0 late collisions
            - lost carrier, - no carrier


提取信息的示例

.. code-block:: python
    :linenos:

    # 提取mtu，返回匹配到的第一个值。
    # mtu的值为：'1500'
    mtu = gl.DUT.getStringValue(cmd=f'display interface GigabitEthernet0/1', 
                                target='Maximum Transmit Unit')

    # 提取 mtu、unicasts，返回匹配的所有值。
    #   mtu的值为['1500'], 
    #   unicasts的值为['-', '15535782', '-', '18381205'] 
    mtu, unicasts = gl.DUT.getStringValue(cmd=f'display interface GigabitEthernet0/1', 
                                    target=['Maximum Transmit Unit', 'unicasts'],
                                    match='all')

    # 指定匹配 value keyword 格式，提取 unicasts，返回匹配的所有值。
    #   unicasts的值为['-', '15535782', '-', '18381205'] 
    mtu, unicasts = gl.DUT.getStringValue(cmd=f'display interface GigabitEthernet0/1', 
                                    target=['unicasts'],
                                    match='all', rule=4)

    # 忽略大小写 
    mtu, unicasts = gl.DUT.getStringValue(cmd=f'display interface GigabitEthernet0/1', 
                                    target=['Unicasts'],
                                    match='all', rule=4, is_strict=False)

getStringValue方法参数如下：
    - ``cmd`` ：命令行或get_buffer，必选参数，类型为字符串或get_buffer方法
    - ``timeout``： 等待回显的最大时间，单位为秒，可选参数，整型，默认值为15秒。只有当回显时间特别长时，才需要设置。当cmd为get_buffer方法时不生效
    - ``target`` ：期望字符串，必选参数，类型为字符串，或包含字符串的列表
    - ``match`` ：匹配第一个或所有，可选参数，类型为字符串，只支持 first 或 all，默认值为first，为all时返回列表，否则返回字符串
    - ``starts/ends`` : 限制查找范围
    - ``rule`` : 用户可指定匹配形式，默认值为0，匹配所有形式，可选值1-4，分别对应以上四种格式
    - ``is_strict``： 是否区分大小写，默认为True，区分大小写


getStringValue2
------------------
参数、用法与 ``getStringValue`` 基本相同，区别只在于取值长度和是否忽略匹配信息中的空格数量，当使用 ``getStringValue`` 获取信息错误时，请使用该方法。

getStringValue2方法额外增加的参数如下：
    - ``ignore_space``：忽略待匹配字符串中的空格数，可选参数，类型为布尔型，默认值为False


观察如下信息

::

    <Sysname> display session table ipv4
    Slot 1:
    Initiator:
        Source    IP/port: 192.168.1.18/1877
        Destination IP/port: 192.168.1.55/22
        DS-Lite tunnel peer: -
        VPN instance/VLAN ID/VLL ID: -/-/-
        Protocol: TCP(6)
        Inbound interface: GigabitEthernet1/0/1
        Source security zone: Trust


提取信息的示例

.. code-block:: python
    :linenos:
    :emphasize-lines: 3,6

    # 提取Source    IP/port，返回匹配到的第一个值。下面两种写法是等价的，src的值为 192.168.1.18/1877。
    # 如果ignore_space设置为False，src的值则为空。
    src = gl.DUT.getStringValue2(cmd=f'display session table ipv4', 
                                target= 'Source IP/port', ignore_space=True)

    src = gl.DUT.getStringValue2(cmd=f'display session table ipv4', 
                                target= 'Source    IP/port', ignore_space=True)


getDebugPktInfo
----------------
大部分情况下，debug信息可以使用 ``CheckCommand`` 检查，但有些场景需要用户完成检查逻辑，比如检查debug的时间截。
框架提供了基础方法 ``getDebugPktInfo``，能够格式化debug信息，简化脚本。


getDebugPktInfo格式化规则如下：
    - 替换debug信息中所有回车符，再以 **星号** 分隔，区分不同的debug报文信息
    - 格式化每个debug报文信息的时间 ，第一个报文的时间设置为0，后续每个报文的时间减去第一个报文的时间，作为该报文的时间标识，即为与第一个报文的时间间隔
    - 每个debug报文信息用 逗号 分隔，再以 **冒号** 或 **等于号** 左边的字符串为key，后边的字符串为value，整理成字典格式的数据， **如果不符合这种格式，用户需要自行整理**
    - 根据用户传入的key的顺序，以列表形式返回每个debug报文的value，列表第一个元素为报文与第一个报文的时间间隔，第二个元素为debug类型，从第三个元素开始是用户传入的value



参考如下示例：

.. code-block:: python
    :linenos:

    debug_info = """*Aug  4 01:42:06:375 2010 Sysname IP6FW/7/debug_case:
    Sending, interface : GigabitEthernet1/0/1, version : 6, traffic class : 0,
    flow label : 0, payload length : 64, protocol : 58, hop limit : 255,
    Src : 1::1, Dst : 1::2,

    prompt: Sending the packet from local interface GigabitEthernet1/0/1
    *Aug  4 01:42:16:377 2010 Sysname IP6FW/7/debug_case:
    Receiving, interface : GigabitEthernet1/0/1, version : 6, traffic class : 0,
    flow label : 0, payload length : 64, protocol : 58, hop limit : 64,
    Src : 1::2, Dst : 1::1,
    prompt: Received an IPv6 packet."""


    # 下面代码返回值为　[[0, 'DebugInfo Sysname IP6FW/7/debug_case:', 'GigabitEthernet1/0/1', '58'], [10, 'DebugInfo Sysname IP6FW/7/debug_case:', 'GigabitEthernet1/0/1', '58']]
    gl.DUT.getDebugPktInfo(debug_info,['interface', 'protocol'])

    # 要区分报文是sending，还是 recerving，则需要用按如下处理
    debug_info.replace('Sending', 'InOut: Sending')
    debug_info.replace('Receiving', 'InOut: Receiving')

    # 下面代码返回值为　[[0, 'DebugInfo Sysname IP6FW/7/debug_case:', 'Sending', 'GigabitEthernet1/0/1', '58'], [10, 'DebugInfo Sysname IP6FW/7/debug_case:', 'Receiving', 'GigabitEthernet1/0/1', '58']]
    gl.DUT.getDebugPktInfo(debug_info,['InOut', 'interface', 'protocol'])



get_port_mac
--------------
获取Comware设备端口的mac地址

``get_port_mac`` 方法支持的参数如下：
  - ``port``: 端口对象或端口名称，端口对象时，执行后，端口对象会添加mac属性
  - ``format``: 格式化方式，默认为冒号分隔，支持 ``:`` ``-`` 两种分隔方式

返回值为端口的mac地址，当端口不存在时，返回空字符串


参考如下示例：

.. code-block:: python
    :linenos:

    # 获取 gl.DUT.PORT的 mac, 执行后，返回mac地址，并且gl.DUT.PORT1对象添加了属性mac
    mac = gl.DUT.get_port_mac(gl.DUT.PORT1)
    print(f'mac attribute is {gl.RT.PORT1.mac}')
    print(f'mac is {mac}')

    # 获取 gl.DUT的vlan-interface100端口的 mac, 由于vlan-interface100不是gl.DUT的端口对象，执行后，只返回mac地址
    mac = gl.RT.get_port_mac('vlan-interface100')
    print(f'vlan-interface100 mac is {mac}')


disconnect/reconnect
------------------------
断开/重连设备，断开连接时会保留终端窗口。如果为多主控设备，会断开/重连设备的所有终端窗口。


参考如下示例：

.. code-block:: python
    :linenos:

    # 断开DUT1的连接
    gl.DUT.disconnect()
    
    # do something

    # 重建DUT1的连接
    gl.DUT.reconnect()



CheckDeviceResource
-----------------------

在网络设备自动化测试中，有时完成配置后，要检查设备部分资源是否正常，此时可以使用 ``CheckDeviceResource`` 方法，目前支持cpu、memory使用率的检查。该方法会影响脚本的执行结果，当该检查失败，即使其它检查都成功，脚本结果也为NG。  

**使用该方法时，需要先调用 initDeviceResource 方法初始化设备资源信息**


``CheckDeviceResource`` 方法支持的参数如下：
  - ``desc``：检查项描述信息，字符串类型，必选参数
  - ``resource``：资源名称，字符串或列表，默认值为 ['cpu', 'memory']，可选参数
  - ``target``：first 或者 last， 与首次或者上一次资源信息对比，默认值为 first，表示与首次对比
  - ``cpu_usage_field``：cpu使用率统计区间， 默认为 'Last 5 sec'，可选参数
  - ``contain_memory``：内存使用率时，是否一并检查container memory， 默认为 False，可选参数
  - ``errors``：允许的误差，字符串类型，默认值为5%，可选参数
  - ``stop_max_attempt`` ：最大检查次数，如果检查结果正确则提前跳出，默认为1
  - ``wait_fixed`` ：检查两次检查的间隔时间，单位为秒， 默认为0


.. code-block:: python
    :linenos:

    # 初始化dut1 dut2 dut3的资源信息
    run_multithread(
        ( gl.dut1.initDeviceResource, ),
        ( gl.dut2.initDeviceResource, ),
        ( gl.dut3.initDeviceResource, ),
    )

    # do something
    
    # 设备资源信息检查
    run_multithread(
        (
            gl.dut1.CheckDeviceResource,
            (f'dut1 检查cpu、memory使用率, 与首次对比，cpu使用率区间 Last 5 min, 容错2%', ),
            {'cpu_usage_field':'Last 5 min', 'errors':'2%', 'stop_max_attempt':3, 'wait_fixed':5}
        ),
        (
            gl.dut2.CheckDeviceResource,
            (f'dut2 只检查memory使用率, 与首次对比，容错6%', ),
            {'resource':'memory', 'errors':'6%', 'stop_max_attempt':3, 'wait_fixed':5}
        ),
        (
            gl.dut3.CheckDeviceResource,
            (f'dut3 检查cpu、memory使用率, 均使用默认值', ),
        ),
    )


    # do something again
    
    # 设备资源信息检查
    run_multithread(
        (
            gl.dut1.CheckDeviceResource,
            (f'dut1 检查cpu、memory使用率, 与上一次对比', ),
            {'target':'last', 'stop_max_attempt':3, 'wait_fixed':5}
        ),
        (
            gl.dut2.CheckDeviceResource,
            (f'dut2 只检查memory使用率, 同时检查container memory，与首次对比，容错6%', ),
            {'resource':'memory', 'contain_memory':True, 'errors':'6%', 'stop_max_attempt':3, 'wait_fixed':5}
        ),
        (
            gl.dut3.CheckDeviceResource,
            (f'dut3 检查cpu、memory使用率, 均使用默认值', ),
        ),
    )


----------------
IP/MAC地址操作
----------------

框架提供了 ``IPAddress`` 库，用于IP(v6)/MAC地址操作。该库为脚本内置库，无需导入，可直接使用。

IP(v6)地址操作方法
----------------------

- ``is_ip_address`` ：判断给定的字符串是否为ip地址，包括ipv4和ipv6
- ``is_ipv4_address`` ：判断给定的字符串是否为ipv4地址
- ``is_ipv6_address`` ：判断给定的字符串是否为ipv6地址
- ``ip_address_class`` ：根据给定的ipv4地址，返回ipv4地址类。如给定的字符串不是ipv4地址，则返回None
- ``incr_ip_address`` ：在给定的ipv4地址上增加给定的步长。如给定的字符串不是ipv4地址，则返回False
- ``incr_ipv6_address`` ：在给定的ipv6地址上增加给定的步长。如给定的字符串不是ipv6地址，则返回False
- ``find_subnet_address`` ：获取不冲突的子网IP地址
- ``find_ipv6_subnet_address`` ：获取不冲突的子网IPv6地址
- ``is_rtEntry`` ：判断指定的字符串是否为IP/mask, ipv6/prefix格式
- ``rtEntry_address`` ：从指定的字符串中获取ip地址，包括ipv4和ipv6，ipv6地址按简写形式返回。如果指定的字符串不符合要求，则返回None
- ``rtEntry_network`` ：从指定的字符串中得到网段地址。如果指定的字符串不符合要求，则返回None
- ``rtEntry_mask`` ：从指定的字符串中获取掩码。如果指定的字符串不符合要求，则返回None
- ``rtEntry_masklen`` ：从指定的字符串中获取掩码长度，返回值类型为整型。如果指定的字符串不符合要求，则返回None
- ``rtEntry_wildcard`` ：从指定的字符串中得到网段反掩码。如果指定的字符串不符合要求，则返回None
- ``compare_ip_address`` ：比较两个IP地址的大小，var1==va2返回0，var1>va2返回1，var1<va2返回-1。如给定的字符串不是ip地址或类型不同，则返回None
- ``ip_address_ltoa`` ：将整数转化为点分十进制形式的IPv4地址
- ``ip_address_tohex`` ：将ipv4地址转化16进制字符串
- ``ipv6_address_ltoa`` 将整数转化为简写形式的IPv6地址
- ``ipv6_makeup_address`` ：将给定的ipv6地址补全为全写格式。如给定的字符串不是ipv6地址，则返回False
- ``ipv6_abbr_address`` ：将给定的ipv6地址转化为简写格式。如给定的字符串不是ipv6地址，则返回False
- ``ipv6_address_tohex`` ：将给定的ipv6地址转化16进制字符串。如给定的字符串不是ipv6地址，则返回False

参考如下示例：

.. code-block:: python
    :linenos:

    # 判断给定字符串是否为IP(v6)地址

    # 以下返回True
    IPAddress.is_ip_address('100.1.1.1')
    IPAddress.is_ip_address('2003::100:1')

    # 以下返回False
    IPAddress.is_ip_address('abcedf')
    IPAddress.is_ip_address('500.1.1.1')
    IPAddress.is_ip_address('100.1.1.1/24')

    # 判断给定字符串是否为IPv4地址，返回值为True或False
    IPAddress.is_ipv4_address('100.1.1.1')

    # 判断给定字符串是否为IPv6地址（忽略大小写），返回值为True或False
    IPAddress.is_ipv6_address('2003::56AE:1')

    # 获取给定IPv4地址的有类类型(A/B/C/D/E)，当给定地址不为IPv4地址时，返回None
    IPAddress.ip_address_class('100.1.1.1')

    # IP(v6)地址递增、递减操作，步长默认1，负数代表递减
    IPAddress.incr_ip_address('100.1.1.1', step=10)
    IPAddress.incr_ip_address('100.1.1.1', step=-8)
    IPAddress.incr_ipv6_address('2003:10AB::1', step=10)
    IPAddress.incr_ipv6_address('2003:10AB::1', step=-20)

    # 获取不冲突的子网IP地址，第一个参数为IP(v6)与子网掩码组合(IP/mask,ipv6/prefix格式)，第二个为已知的地址
    # 返回字符串 100.1.1.3
    IPAddress.find_subnet_address('100.1.1.0/24', '100.1.1.1 100.1.1.2')
    # 返回字符串 2003:10AB::3
    IPAddress.find_ipv6_subnet_address('2003:10AB::/64', '2003:10AB::1 2003:10AB::2 2003:10AB::4')
    
    # 判断指定的字符串是否为IP/mask, ipv6/prefix格式，返回值为True或False
    IPAddress.is_rtEntry('100.1.1.1/24')
    IPAddress.is_rtEntry('2003:10AB::1/64')
    
    # 从IP(v6)与子网掩码组合中获取IP(v6)地址，IPv6地址以简写形式返回
    IPAddress.rtEntry_address('192.168.1.1/16')
    IPAddress.rtEntry_address('2001:0C30::0001/64')

    # 从IP(v6)与子网掩码组合中获取IP(v6)网段地址
    # 返回字符串 192.168.0.0
    IPAddress.rtEntry_network('192.168.1.1/16')
    # 返回字符串 2001:0C30::
    IPAddress.rtEntry_network('2001:0C30::0001/64')

    # 从IP(v6)与子网掩码组合中获取IP(v6)地址的掩码、掩码长度
    # 分别返回字符串 255.255.0.0，整型 16
    IPAddress.rtEntry_mask('192.168.1.1/16')
    IPAddress.rtEntry_masklen('192.168.1.1/16')
    # 分别返回字符串 FFFF:FFFF:FFFF:FFFF::，整型 64
    IPAddress.rtEntry_mask('2001:0C30::0001/64')
    IPAddress.rtEntry_masklen('2001:0C30::0001/64')

    # 从IP(v6)与子网掩码组合中获取IP(v6)地址的反掩码
    # 返回字符串 0.0.255.255
    IPAddress.rtEntry_wildcard('192.168.1.1/16')
    # 返回字符串 ::FFFF:FFFF:FFFF:FFFF
    IPAddress.rtEntry_wildcard('2001:0C30::0001/64')

    # 判断两个IP(v6)地址大小关系，返回值类型为整型，相等返回0，第一个大于第二个返回1，第一个小于第二个返回-1，
    # 返回整型 -1
    IPAddress.compare_ip_address('192.168.1.1', '192.168.1.2')
    # 返回整型 1
    IPAddress.compare_ip_address('2001:0C30::0005', '2001:0C30::1')

    # 10进制整数转换成IP(v6)地址
    IPAddress.ip_address_ltoa(128)
    IPAddress.ipv6_address_ltoa(4096000000)

    # IPv6地址全写、简写形式转换
    # 返回字符串 2001:0C30:0000:0000:0000:0000:0000:0005
    IPAddress.ipv6_makeup_address('2001:0C30::0005')
    # 返回字符串 2001:C30::5
    IPAddress.ipv6_abbr_address('2001:0C30:0000:0000:0000:0000:0000:0005')

    # 将IPv4地址转换为16进制字符串
    # 返回字符串 0xC0 0xA8 0x01 0x03
    IPAddress.ip_address_tohex('192.168.1.3')

    # 将IPv6地址转换为16进制字符串
    # 返回字符串 0x20 0x01 0x0C 0x30 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x01
    IPAddress.ipv6_address_tohex('2001:0C30::0001')



MAC地址操作方法
----------------

- ``is_mac_address`` ：判断给定的字符串是否符合mac地址格式，符合返回True，否则返回False。支持[-:.]3分和6分
- ``incr_mac_address`` ：MAC地址递增，输入非法时，返回None。支持[-:.]3分和6分。increment  递增步长,默认为1,为整型数
- ``format_mac_address`` ：按要求格式化mac地址。如果指定的字符串不属于mac地址，返回None


参考如下示例：

.. code-block:: python
    :linenos:

    # 判断给定字符串是否为MAC地址，支持[-:.]3分和6分
    IPAddress.is_mac_address('00:01:02:03:04:05')
    IPAddress.is_mac_address('1-2-3')
    IPAddress.is_mac_address('1.2.3')

    # MAC地址递增、递减，支持[-:.]3分和6分。步长默认1，负数代表递减，支持10进制和16进制
    # 按原格式返回
    IPAddress.incr_mac_address('0.1.0.2.0.3', step=0xf)
    IPAddress.incr_mac_address('00:01:02:03:04:05', step=-0xf)
    IPAddress.incr_mac_address('0001-0203-0405', step=1)

    # 格式化mac地址，包含如下参数：
    # var   代表mac地址的字符串
    # format_type  要转换为MAC地址格式的位数，如0-0-1为3；如0-0-0-0-0-1为6；默认为6
    # splitchar   要转换为MAC地址格式的分隔符，支持- . : 空格，默认为空格，转换为数字的列表{0X00 0X00 0X00 0X00 0X00 0X01}
    IPAddress.format_mac_address("00:01:02:03:04:05", splitchar='.')
    IPAddress.format_mac_address("00-01-02-03-04-05", format_type=3, splitchar='-')
    IPAddress.format_mac_address("1-2-3")
    
----------------
PCAP文件操作
----------------

框架提供了 ``Packet`` 库，包含PCAP文件操作方法。该库为脚本内置库，无需导入，可直接使用。

PCAP文件操作方法
----------------------

``getFilterPktCount`` ：解析pcap文件，返回符合过滤条件的报文数量
  - ``pcap_file_path``: pcap文件路径
  - ``filter``: 过滤条件，支持wireshark格式的过滤条件，str类型，如 'http and ip.src==192.168.1.1'

.. code-block:: python
    :linenos:

    # 解析test.pcap文件，获取符合过滤条件的报文个数
    packet_count = Packet.getFilterPktCount('d:/test.pcap', 'tcp and ip.src==10.111.8.188')


----------------
iNode上下线操作
----------------

框架提供了 ``Packet`` 库，包含了iNode上下线接口操作方法。该库为脚本内置库，无需导入，可直接使用。

iNode Portal上下线操作
----------------------

``onlineiNodeByPortal`` ：调用iNode命令行，进行Portal认证上线
  - ``scenario``:     连接场景，在iNode场景管理的下一级标签名称，一般情况下有公司内网、外网
  - ``connection``:   连接名称，场景下的名称，如Portal连接
  - ``user``:         认证用户名
  - ``password``:     认证用密码
  - ``server_ip``:    服务器的IPv4地址


``offlineiNodeByPortal`` ：调用iNode命令行，进行Portal认证下线
  - ``scenario``:     连接场景，在iNode场景管理的下一级标签名称，一般情况下有公司内网、外网
  - ``connection``:   连接名称，场景下的名称，如Portal连接

.. code-block:: python
    :linenos:

    # 调用iNode进行Port上线
    Packet.onlineiNodeByPortal(scenario='公司内网', connection='Portal连接', user='z123456', password='xxxxx', server_ip='192.168.1.1')
    
    # 调用iNode进行portal下线
    Packet.offlineiNodeByPortal(scenario='公司内网', connection='Portal连接')

iNode SSLVPN上下线操作
----------------------

``onlineiNodeBySSL`` ：调用iNode命令行，进行SSLVPN认证上线
  - ``scenario``:         连接场景，在iNode场景管理的下一级标签名称，一般情况下有公司内网、外网
  - ``connection``:       连接名称，场景下的名称，如SSLVPN连接
  - ``user``:             认证用户名
  - ``password``:         认证用密码
  - ``gateway_ip``:       网关IPv4地址
  - ``gateway_domain``:   网关域名
  - ``gateway_port``:     网关端口号，默认443
  - ``login_domain``:     登录域名 


``offlineiNodeBySSL`` ：调用iNode命令行，进行SSLVPN认证下线
  - ``scenario``:     连接场景，在iNode场景管理的下一级标签名称，一般情况下有公司内网、外网
  - ``connection``:   连接名称，场景下的名称，如SSLVPN连接

.. code-block:: python
    :linenos:

    # 调用iNode进行SSLVPN上线
    Packet.onlineiNodeBySSL(scenario='外网', connection='ssl连接', user='z123456', password='xxxxx', gateway_ip='192.168.1.1',
                           gateway_domain='@h3c', login_domain='@test')
    
    # 调用iNode进行SSLVPN下线
    Packet.offlineiNodeBySSL(scenario='外网', connection='ssl连接')


-----------
脚本相关
-----------

获取脚本当前位置
----------------------


.. code-block:: python
    :linenos:

    # 导入os.path库
    import os.path

    # 获取当前脚本的绝对路径，返回格式为 d:\script\stp\topo1\test_demo.py
    current_file = os.path.abspath(__file__)

    # 获取当前目录的绝对路径，返回格式为 d:\script\stp\topo1
    current_dir = os.path.dirname(os.path.abspath(__file__))

    # 获取当前目录上一层目录的绝对路径，返回格式为 d:\script\stp
    current_parent_dir = os.path.abspath(os.path.join(current_dir, '..'))

    # 获取当前目录上两层目录的绝对路径，返回格式为 d:\script
    current_parent2_dir = os.path.abspath(os.path.join(current_dir, '../..'))


-------------
解析配置文件
-------------

在一些场景下，脚本执行时需要若干信息，可以把这些信息保存在配置文件中可以简化管理，在conftest中使用 ``config_file_parser`` 解析之后在脚本中使用。


``config_file_parser`` ：

- 入参：为字符串类型，代表配置文件的绝对路径，支持 ``.ini/.yml/.json/.txt`` 四种后缀的文件
- 返回值: 字典类型

conftest代码示例：

.. code-block:: python
    :linenos:

    # conftest.py
    
    @atf_time_stats("ATFSetupTime")
    @atf_adornment
    def setup():
        # 获取当前文件目录的绝对路径
        current_dir = os.path.dirname(os.path.abspath(__file__))
        # 解析配置文件
        config_path = os.path.join(current_dir, 'resource/config.ini')
        # 将返回值添加至CVarsAndFuncs类，以类属性供脚本使用
        CVarsAndFuncs.config_param = config_file_parser(config_path)


脚本代码示例：

.. code-block:: python
    :linenos:

    # test_demo.py
    from .conftest import pre_func, post_func, CVarsAndFuncs

    # 以类CVarsAndFuncs属性方式访问配置文件解析结果
    print(CVarsAndFuncs.config_param)


各后缀文件内容格式及解析后的字典：

::

    # .ini格式
    [Settings]
    username = admin
    password = secret

    [Database]
    host = localhost
    port = 3306

    # ==> {'Settings': {'username': 'admin', 'password': 'secret'}, 'Database': {'host': 'localhost', 'port': '3306'}}

    # .yml格式
    Settings:
    username: admin
    password: secret

    Database:
    host: localhost
    port: 3306

    # ==> {'Settings': {'username': 'admin', 'password': 'secret'}, 'Database': {'host': 'localhost', 'port': 3306}}

    # .json格式
    {
        "Settings": {
            "username": "admin",
            "password": "secret"
        },
        "Database": {
            "host": "localhost",
            "port": 3306
        }
    }

    # ==> {'Settings': {'username': 'admin', 'password': 'secret'}, 'Database': {'host': 'localhost', 'port': 3306}}

    # .txt格式
    Settings_username = admin
    Settings_password = secret

    Database_host = localhost
    Database_port = 3306

    # ==> {'Settings_username': 'admin', 'Settings_password': 'secret', 'Database_host': 'localhost', 'Database_port': '3306'}
