.. _topics-脚本规则:


脚本规则
==========

----------
归档规则
----------

1、**脚本按使用的拓扑进行归档，同一模块使用相同拓扑的脚本归档到一个目录**

2、目录包含 ``__init__.py``、 ``conftest.py``、 ``拓扑文件`` 和 ``脚本``，当有辅测文件，要求放到 ``resource`` 目录

具体方式下见：

::

    测试套
       |----- conftest.py*
       |----- resource*
       |----- LLDP^
           |----- conftest.py*
           |----- resource*
           |----- topo1
                |----- __init__.py
                |----- conftest.py
                |----- resource*
                |----- demo_topo_1.topox
                |----- test_lldp_1.py
                |----- test_lldp_x.py
           |----- topo2
                |----- __init__.py
                |----- conftest.py
                |----- resource*
                |----- demo_topo_2.topox
                |----- test_lldp_11.py
                |----- test_lldp_xx.py
        |----- STP^
            |----- conftest.py*
            |----- resource*
            |----- topo1
                |----- __init__.py
                |----- conftest.py
                |----- resource*
                |----- demo_topo_1.topox
                |----- test_stp_1.py
                |----- test_stp_x.py

.. admonition::  **规则**

    1) \*表示文件有、无都可以， ^代表该层为模块名
    
    2) 由于使用了python包机制，脚本文件、脚本文件所在的上一级文件命名只能由数字、字母、下划线组成，并且以字母开头
    
    3) ``__init__.py`` 文件只能在topo一级的文件夹且必须存在， **其它目录不能有该文件**
    

--------------
conftest
--------------
conftest.py文件框架的一类重要文件，用于保存测试脚本共用的信息，不可删除。

- 变量 level: 脚本执行时使用二层端口或三层端口：只支持2或3，int类型
- 变量 topo: 描述拓扑文件所在的相对路径，str类型
- 类 CVarsAndFuncs: 用于定义拓扑级公共变量或方法（通过类属性声明）
- 方法 setup/teardown: 用于配置/清除拓扑级的公共配置

模板如下：

.. code-block:: python
    
    from pytest import fixture
    from pytest_atf import *
    from pytest_atf.atf_globalvar import globalVar as gl

    # --------用户修改区 -------------------

    # 执行层及使用拓扑文件名称
    level = 3
    topo = r'demo.topox'

    # 用于声明脚本共用的变量或方法，不能修改类名。
    # 变量或方法都要定义为类属性，不要定义为实例属性。
    class CVarsAndFuncs:
        pass

    # 不能删除setup/teardown的装饰器
    @atf_time_stats("ATFSetupTime")
    @atf_adornment
    def setup():
        pass

    @atf_time_stats("ATFTeardownTime")
    @atf_adornment
    def teardown():
        pass
    
    #用于用户自定义在测试用例前后/用例间/步骤前后/步骤间自定义操作，配合设置开关使用，举例：--extra-operations="{'class':True}"
    @decorator_for_user_log()
    def pre_func():
        pass

    @decorator_for_user_log()
    def post_func():
        pass
    # ---------END-----------

    @fixture(scope="package", autouse=True)
    def my_fixture_setup_and_teardown():
        atf_topo_map(topo, level)
        try:
            setup()
            yield
        finally:
            teardown()
            atf_topo_unmap()


    @fixture(scope="package")
    def VarsAndFuncs():
        return CVarsAndFuncs


----------
脚本
----------
框架定义一个测试类为一个脚本，测试类里的方法为测试步骤，各部分规则和作用如下：

- 导入库：必须导入的库，使用VTP-CLOUD创建脚本时自动导入，否则手工导入
- 脚本对应用例信息：包含module/case_no两个参数，module可为空，case_no必须与用例编号对应
- 脚本tag：脚本标识 pytestmark，用于在测试集执行时过滤脚本，具体标识可根据实现情况自定义，可选。
- 测试类名称：必须以Test开头，建议使用TestClass或者TestClass_模块名
- 类方法setup_class：下发脚本级公共配置，也可以为实例方法， **不支持包含检查项**
- 类方法teardown_class：清除脚本级公共配置，也可以为实例方法， **不支持包含检查项**
- 实例方法test_step*：测试步骤，必须以test_step开头，具体操作和检查
  
另外，鉴于框架查找脚本时，会执行测试类的代码，测试类（TestClass）中除了声明类变量的其它代码推荐放到方法（def）里，避免查找脚本时出现无谓的耗时。

模板如下：

.. code-block:: python

    # 如下库必须导入，可根据需要导入其它库
    from pytest_atf import *
    from pytest_atf.atf_globalvar import globalVar as gl
    from .conftest import CVarsAndFuncs

    # 脚本对应用例的信息，case_no 必须与用例编号对应，如果对应多个用例，用例编号间用英文逗号分隔
    module = ''
    case_no = 'xxx'

    # 脚本标识，每个标识必须使用 "pytest.mark." 声明，可选
    pytestmark = [pytest.mark.FUN, pytest.mark.weight6]

    # 测试类
    class TestClass:
        '''
        XXX此处为脚本测试目的以及脚本开发责任人，格式参考如下：
        测试目的：模板展示
        作者：zhangsan/12345
        开发时间：2022.10.10
        修改记录：
        '''

        @classmethod
        def setup_class(cls):
            '''
            脚本初始配置
            '''
            pass

        @classmethod
        def teardown_class(cls):
            '''
            清除脚本初始配置
            '''
            pass

        def test_step_1(self):
            '''
            XXX此处为脚本测试步骤1描述
            '''
            pass

        def test_step_x(self):
            '''
            XXX此处为脚本测试步骤x描述
            '''
            pass


.. note:: 使用VTP-CLOUD新建脚本目录或脚本时，会以固定模板生成相关文件，方便脚本开发。


--------------------------
脚本导入conftest.py的规则
--------------------------

脚本导入conftest.py文件中函数的方法：

1、使用点（.）直接导入包中的conftest.py中的函数：此时要求脚本父级目录的名称不能包含点（.）

.. code-block:: python

    # /20_1_2_3_stp/test_case.py
    
    # 如下库必须导入，可根据需要导入其它库
    from pytest_atf import *
    from pytest_atf.atf_globalvar import globalVar as gl
    from .conftest import CVarsAndFuncs


2、导入当前模块的conftest.py中的函数：此时脚本父级目录的名称 **可以** 包含点（.），但其上级目录不能再包含conftest.py文件

.. code-block:: python

    # /20.1.2.3_stp/test_case.py
    
    # 如下库必须导入，可根据需要导入其它库
    from pytest_atf import *
    from pytest_atf.atf_globalvar import globalVar as gl
    from conftest import CVarsAndFuncs



----------
脚本标记
----------
框架支持对脚本添加各类标记，用于在收集、筛选和执行过程中选择或跳过测试。为可选。

用户添加的标记需要使用 ``pytest.mark.`` 声明，如 ``pytest.mark.FUN`` 。

标记之间支持 **与、或** 关系，书写时只带标记，如 ``FUN and (weight5 or weight6)`` 表示执行包含 ``weight5`` 或 ``weight6`` 标记，并且包含 ``FUN`` 标记的脚本。


脚本示例：

.. image:: ./images/脚本标记1.jpg


在VTP-CLOUD上使用示例：

.. image:: ./images/脚本标记2.jpg


--------------
公共变量
--------------
公共变量（方法）分为case级、topo级、suite级3个级别

case级
--------
一个脚本的多个步骤共用的变量（方法），要求声明为类变量（方法）或全局变量（方法）

.. code-block:: python
    :linenos:

    g_var1 = '全局变量，多个类都会用到'

    def g_fun1(desc):
        print('全局方法，可以直接调用')

    class TestClass:
        '''
        测试目的：展示类变量（方法）的使用
        作者：zhangsan/12345
        开发时间：2022.10.10
        修改记录：
        '''

        var1 = '类变量，多个步骤都会用到'

        def fun1(desc):
            print('普通方法，通过类名调用')

        def test_step_1(self):
            '''
            XXX此处为脚本测试步骤1描述
            '''
            TestClass.var1 = 'step 1 修改了变量var1的值'

        def test_step_x(self):
            '''
            XXX此处为脚本测试步骤x描述
            '''
            
            TestClass.var1 = 'step 2 修改了变量var1的值'
            TestClass.fun1('通过类名调用普通方法')
            g_fun1('直接调用全局方法')
            

topo级
--------
有三种方法，实现多个脚本共用的变量（方法）。

- 1、使用全局类：在conftest.py的 ``CVarsAndFuncs`` 类中声明，在脚本导入 ``CVarsAndFuncs`` (模板中已自动导入)，通过类属性访问公共变量（方法）。 **推荐使用该方法**

代码示例：

.. code-block:: python
    :linenos:

    # conftest.py

    # -------------section of custom fixture---------------
    class CVarsAndFuncs:
        g_var1 = {'a': 10, 'b': 11}
        g_var2 = 'this is a string'
        g_var3 = ['ele_1', 'ele_2']

        @classmethod
        def func1(cls, a, b):
            var = 'do something...'
            return a+b
    
    @pytest.fixture(scope='package')
    def VarsAndFuncs():
        return CVarsAndFuncs

    #---------------section end-----------------------

.. code-block:: python
    :linenos:

    # test_case.py
    from conftest import CVarsAndFuncs

    def test_1(self):
        """for testing CVarsAndFuncs
        """
        assert CVarsAndFuncs.g_var1['a'] == 10
        assert CVarsAndFuncs.fun1(10, 20) == 30


结构示例：

.. image:: ./images/公共变量示例1.jpg



- 2、使用fixture：在conftest.py的 ``CVarsAndFuncs`` 类中声明，在脚本的step中导入 ``VarsAndFuncs`` ，通过类属性访问公共变量（方法）。 **注意：fixture不能在脚本的setup、teardown中使用**

代码示例：

.. code-block:: python
    :linenos:

    # conftest.py

    # -------------section of custom fixture---------------
    class CVarsAndFuncs:
        g_var1 = {'a': 10, 'b': 11}
        g_var2 = 'this is a string'
        g_var3 = ['ele_1', 'ele_2']

        @classmethod
        def func1(cls, a, b):
            var = 'do something...'
            return a+b
    
    @pytest.fixture(scope='package')
    def common_string():
        return 'Hello, World!'

    @pytest.fixture(scope='package')
    def my_test_fun():
        def fun(a,b):
            return a + b
        return fun

    @pytest.fixture(scope='package')
    def VarsAndFuncs():
        return CVarsAndFuncs

    #---------------section end-----------------------

.. code-block:: python
    :linenos:

    # test_case.py

    def test_1(self, VarsAndFuncs):
        """for testing VarsAndFuncs
        """
        assert VarsAndFuncs.g_var1['a'] == 10
        assert VarsAndFuncs.fun1(10, 20) == 30

    def test_2(self, common_string):
        """for step 2
        """
        assert common_string == 'Hello, World!'
    
    def test_3(self, my_test_fun):
        """for step 3
        """
        assert my_test_fun(1,5) == 6


结构示例：

.. image:: ./images/公共变量示例2.jpg


- 3、使用resource：增加resource文件夹，并创建一个py文件用于保存公共变量（方法），通过模块的属性访问公共变量（方法）。

代码示例：

.. code-block:: python
    :linenos:

    # resource/vars_and_funcs.py

    # 公共变量、方法
    g_var1 = {'a': 10, 'b': 11}
    g_var2 = 'this is a string'
    g_var3 = ['ele_1', 'ele_2']


    def fun1( a, b):
        var = 'do something...'
        return a+b


.. code-block:: python
    :linenos:

    # test_case.py

    from .resource import vars_and_funcs

    class TestClass():
        """for testing public variable
        """

        def test_1(self, ):
            """for step 1
            """
            assert vars_and_funcs.g_var2 == 'this is a string'
            assert vars_and_funcs.fun1(1,2) == 3


.. note:: ``conftest.py`` 导入resource文件夹路径时，要注意其与路径关系，以 ``conftest.py`` 的路径为当前路径进行查找


结构示例：

.. image:: ./images/公共变量示例3.jpg


suite级
--------
suite级变量（方法）提供方式推荐使用topo级的第二种方式。如果使用第一种方式，要注意保存公共变量（方法）的类名以及fixture的名称不要与topo级的冲突。


--------------
用户自定义库
--------------
在脚本开发过程中，用户自定义的库要求归档到resource目录。根据resource目录与脚本所在层级不同，可分为两类：

1、与脚本同级目录：在脚本中使用点（.）引入当前包的 resource 目录。

代码示例：

.. code-block:: python
    :linenos:

    # test_demo.py
    from .resource import sub_dev_res1



2、与脚本不在同级目录：需要先将 resource 目录添加到 sys.path中。鉴于多个脚本使用，建议将其添加到conftest.py文件中，方法见下。 


.. code-block:: python
    :linenos:

    # conftest.py
    import os.path, sys

    # 获取当前文件目录的绝对路径
    current_dir = os.path.dirname(os.path.abspath(__file__))

    # 当resource为脚本的上一层级时，添加上一层目录（..）到 sys.path，以便能够找到 resource 目录
    # sys.path.insert(0, os.path.abspath(os.path.join(current_dir, '..')))

    # 当resource为脚本的上两层级时，添加上两层目录（../../）到 sys.path，以便能够找到 resource 目录
    sys.path.insert(0, os.path.abspath(os.path.join(current_dir, '../..')))

    # 依次类推 ...


.. code-block:: python
    :linenos:

    # test_demo.py
    from resource import dev_res1


.. note:: 与脚本不在同级目录时，只支持一个resource，不能既有上一层，又有上两层。


脚本目录示例：

.. image:: ./images/resource示例.jpg


