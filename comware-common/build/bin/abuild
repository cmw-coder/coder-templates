#!/bin/bash

# Jenkins配置
JENKINS_SERVER_URL="http://10.153.3.174:8080"
JENKINS_USERNAME="h25380"
JENKINS_API_TOKEN="117b0fdde578a988ec1be741dd777c1a1c"
JENKINS_AUTH="${JENKINS_USERNAME}:${JENKINS_API_TOKEN}"

# 获取Jenkins Crumb以防止CSRF保护
get_jenkins_crumb() {
  curl -s --user "${JENKINS_AUTH}" "${JENKINS_SERVER_URL}/crumbIssuer/api/json" | jq -r '.crumb'
}

# 获取构建编号
get_build_number() {
  local server=$1
  local task_name=$2
  local build_cmd=$3
  
  # 等待队列中的任务开始运行
  while true; do
    local queue_info=$(curl -s --user "${JENKINS_AUTH}" "${JENKINS_SERVER_URL}/queue/api/json")
    local is_exist=false
    
    if echo "$queue_info" | jq -e '.items[] | select(.task.name == "'"$task_name"'")' > /dev/null; then
      # 检查是否是我们的构建命令和用户ID
      if echo "$queue_info" | jq -e '.items[] | select(.task.name == "'"$task_name"'") | 
        (.actions[0].parameters[0].value == "'"$build_cmd"'" and .actions[1].causes[0].userId == "'"$JENKINS_USERNAME"'") or
        (.actions[1].parameters[0].value == "'"$build_cmd"'" and .actions[0].causes[0].userId == "'"$JENKINS_USERNAME"'")' > /dev/null; then
        is_exist=true
        break
      fi
    fi
    
    if [ "$is_exist" = "false" ]; then
      break
    fi
    sleep 3
  done
  
  # 获取下一个构建号减1
  local next_build_number=$(curl -s --user "${JENKINS_AUTH}" "${JENKINS_SERVER_URL}/job/${task_name}/api/json" | jq '.nextBuildNumber - 1')
  
  # 查找匹配的构建
  local i=0
  while [ $next_build_number -gt 0 ] && [ $i -lt 10 ]; do
    local job_info=$(curl -s --user "${JENKINS_AUTH}" "${JENKINS_SERVER_URL}/job/${task_name}/${next_build_number}/api/json")
    
    # 处理可能的两种参数顺序
    if echo "$job_info" | jq -e '(.actions[0].parameters[0].value == "'"$build_cmd"'" and .actions[1].causes[0].userId == "'"$JENKINS_USERNAME"'") or
        (.actions[1].parameters[0].value == "'"$build_cmd"'" and .actions[0].causes[0].userId == "'"$JENKINS_USERNAME"'")' > /dev/null; then
      echo $next_build_number
      return 0
    fi
    
    next_build_number=$((next_build_number - 1))
    i=$((i + 1))
  done
  
  echo "-1"
  return 1
}

# 从构建控制台输出中提取版本路径
get_version_path() {
  local task_name=$1
  local console_output=$2
  local version_path_prefix=""
  local version_file_path=""
  local last_path_name=""
  
  # 查找Build.html路径
  version_path_prefix=$(echo "$console_output" | grep -E '^\s*.*Build\.html' | head -1)
  if [ -n "$version_path_prefix" ]; then
    # 提取路径前缀
    version_path_prefix=$(echo "$version_path_prefix" | sed -E 's/^\s*(.*Build\.html).*/\1/')
    version_path_prefix=${version_path_prefix%\\Build.html}
    version_path_prefix=${version_path_prefix//\\/\/}
    last_path_name=$(echo "$version_path_prefix" | awk -F/ '{print $NF}')
    
    # 根据任务类型查找相应的文件路径
    if [ "$task_name" = "V9ABUILD_CI" ]; then
      version_file_path=$(echo "$console_output" | grep -E "$last_path_name.*TARGET.*\.tar\.gz" | head -1)
      if [ -n "$version_file_path" ]; then
        version_file_path=$(echo "$version_file_path" | sed -E "s/.*($last_path_name\/TARGET\/.*)/\1/")
      fi
    else
      version_file_path=$(echo "$console_output" | grep -E "$last_path_name.*TARGET.*\.ipe" | head -1)
      if [ -n "$version_file_path" ]; then
        version_file_path=$(echo "$version_file_path" | sed -E "s/.*($last_path_name\/TARGET\/.*\.ipe\/)/\1/")
      fi
    fi
  fi
  
  # 返回完整版本路径
  if [ -n "$version_path_prefix" ] && [ -n "$version_file_path" ]; then
    echo "file:${version_path_prefix}/${version_file_path}"
  else
    echo ""
  fi
}

# 获取构建错误信息
get_error_result() {
  local server=$1
  local build_number=$2
  local task_name=$3
  
  # 获取构建信息和控制台输出
  local build_info=$(curl -s --user "${JENKINS_AUTH}" "${JENKINS_SERVER_URL}/job/${task_name}/${build_number}/api/json")
  local build_url=$(echo "$build_info" | jq -r '.url')
  local console_output=$(curl -s --user "${JENKINS_AUTH}" "${build_url}consoleText")
  local job_status=$(echo "$build_info" | jq -r '.result')
  
  # 初始化结果变量
  local ret=0
  local version_path=""
  local error_info="{}"
  
  if [ "$job_status" = "SUCCESS" ]; then
    version_path=$(get_version_path "$task_name" "$console_output")
  else
    ret=-1
    # 提取错误信息
    local error_list=$(echo "$console_output" | grep -E '^(.*):([0-9]+):\s*(error:|undefined reference|fatal error:)(.*)$')
    if [ -n "$error_list" ]; then
      # 将错误信息格式化为JSON
      error_info="[
"
      local file_count=0
      local unique_files=()
      
      while IFS= read -r line; do
        local file=$(echo "$line" | sed -E 's/^([^:]+):([0-9]+):.*/\1/')
        local line_num=$(echo "$line" | sed -E 's/^([^:]+):([0-9]+):.*/\2/')
        
        # 处理文件名中可能包含的行号
        if [[ "$file" == *":"* ]]; then
          line_num=${file##*:}
          file=${file%:*}
        fi
        
        unique_files+=("$file")
        
        if [ ${#error_info} -gt 2 ]; then
          error_info="${error_info},
"
        fi
        error_info="${error_info}{\"FILE\":\"${file}\",\"LINENUMBER\":${line_num},\"ALARM\":\"${line}\"}"
      done <<< "$error_list"
      
      error_info="${error_info}]"
      
      # 如果错误文件超过5个，清空错误信息
      unique_files=($(printf "%s\n" "${unique_files[@]}" | sort -u))
      if [ ${#unique_files[@]} -gt 5 ]; then
        error_info="[]"
      fi
    else
      error_info="[]"
    fi
  fi
  
  # 构建JSON结果
  echo "{\"result\":${ret},\"version_path\":\"${version_path}\",\"build_info_output\":\"${build_url}console\",\"error_info\":${error_info}}"
}

# 监控构建结果
get_result_number() {
  local server=$1
  local task_name=$2
  local build_cmd=$3
  local web_task_id="${4:-""}"
  
  local build_number=$(get_build_number "$server" "$task_name" "$build_cmd")
  local date1=$(date +"%Y%m%d.%H%M%S")
  
  if [ "$build_number" = "-1" ]; then
    echo "Cancel."
    local job_status="Cancel"
  else
    local build_info=$(curl -s --user "${JENKINS_AUTH}" "${JENKINS_SERVER_URL}/job/${task_name}/${build_number}/api/json")
    local build_url=$(echo "$build_info" | jq -r '.url')
    echo "${build_number} ${task_name}_BUILDING ${date1} -- ${build_url}console"
    
    local build_console="${build_url}console"
    echo "$web_task_id 链接:$build_console"
    
    # 等待构建完成
    local job_status=$(echo "$build_info" | jq -r '.result')
    while [ "$job_status" = "null" ]; do
      sleep 3
      build_info=$(curl -s --user "${JENKINS_AUTH}" "${JENKINS_SERVER_URL}/job/${task_name}/${build_number}/api/json")
      job_status=$(echo "$build_info" | jq -r '.result')
    done
    
    local date2=$(date +"%Y%m%d.%H%M%S")
    local seconds=$(($(date -d "$date2" +%s) - $(date -d "$date1" +%s)))
    echo "${build_number} ${task_name}_${job_status} ${date2} ${seconds}S ${build_url}console"
  fi
  
  echo $build_number
}

# 执行构建作业
build_job_compile() {
  local svn_url=$1
  local ipe_packet_name=$2
  local module=$3
  local user_number=${4:-"$JENKINS_USERNAME"}
  local timestamp=$5
  local lib_path=$6
  local version_type=${7:-"release"}
  
  # 错误处理函数
  handle_error() {
    echo "[Error] ABuild failed due to exception: $1"
    return 1
  }
  
  local server="server" # 仅作为占位符，在Bash中不需要
  
  if [[ "$svn_url" == *"V9R1"* ]]; then
    local task_name="V9ABUILD"
  else
    local task_name="ABUILD"
  fi
  
  # 构建命令
  local build_cmd="-e ${ipe_packet_name} -s ${svn_url}"
  if [ -n "$module" ]; then
    build_cmd="${build_cmd}:${module}"
  fi
  
  if [ "${version_type,,}" != "debug" ]; then
    build_cmd="${build_cmd} -r"
  fi
  
  if [ -n "$lib_path" ]; then
    build_cmd="${build_cmd} -i ${lib_path}"
  fi
  
  if [ -n "$timestamp" ]; then
    build_cmd="${build_cmd} -v ${timestamp} -uk"
  fi
  
  echo "[Info] Triggering Jenkins ABuild. Command: ${build_cmd}"
  
  # 获取CSRF令牌
  local crumb=$(get_jenkins_crumb)
  if [ -z "$crumb" ]; then
    handle_error "Failed to get Jenkins crumb"
    return 1
  fi
  
  # 触发Jenkins构建
  curl -s -X POST --user "${JENKINS_AUTH}" -H "Jenkins-Crumb: ${crumb}" \
    "${JENKINS_SERVER_URL}/job/${task_name}/buildWithParameters" \
    --data-urlencode "BUILD_CMD_PARAM=${build_cmd}" \
    --data-urlencode "FAKE_USER=${user_number}" || {
      handle_error "Failed to trigger Jenkins build"
      return 1
    }
  
  # 获取构建编号及结果
  local abuild_number=$(get_result_number "$server" "$task_name" "$build_cmd")
  if [ -z "$abuild_number" ] || [ "$abuild_number" = "Cancel" ]; then
    handle_error "Build was cancelled or failed to get build number"
    return 1
  fi
  
  local result_info=$(get_error_result "$server" "$abuild_number" "$task_name")
  
  echo "$result_info"
}

# 主函数
main() {
  if [ $# -lt 2 ]; then
    echo "Usage: abuild <svn_url> <ipe_packet_name> [module] [user_number] [timestamp] [lib_path] [debug|release]"
    exit 1
  fi
  
  local result=$(build_job_compile "$1" "$2" "${3:-""}" "${4:-$JENKINS_USERNAME}" "${5:-""}" "${6:-""}" "${7:-release}")
  
  if [ -n "$result" ]; then
    echo "Build Result: $result"
  else
    echo "Build failed or encountered an error."
  fi
}

# 执行主函数
main "$@"
