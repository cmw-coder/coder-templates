.. _topics-命令行回显检查:


命令行回显检查
================
命令行回显检查是非常重要的检查手段，其实现方法多种多样，为了简化脚本开发复杂度、提升脚本可读性，框架提供CheckCommand方法对Comware设备的回显信息进行检查。


CheckCommand
---------------

-------------
简介
-------------

CheckCommand方法支持对命令行回显或debug信息进行检查，其功能如下：

- 支持连续、不连续字符串检查，以及其出现次数的检查
- 支持分组检查、表格检查、json检查
- 支持对数字的范围检查
- 支持使用正则表达式对象进行检查
- 支持期望存在或不存在的检查
- 支持同时检查多个字段，各字段支持 ``与`` ``或`` 关系
- 支持缩减回显信息检查范围
- 支持失败后重试机制

.. admonition:: 检查原则

    1) 以预期的各字符串设置检查边界，避免由于包含关系导致检查错误，如预期 ``Status:UP`` ，实际为 ``AdminStatus:UP``
    
    2) 将多个空格处理成一个空格，忽略预期与实际空格不一致的情况；为了便于书写，忽略 ``:`` ``=`` 前后的空格
    
    3) 所有预期默认忽略大小写（正则表达式对象除外），如需区分大小写，使用 ``is_stric=True``
    
    4) 命令行下发失败时，默认检查失败，如需检查失败信息，使用 ``ignore_cmd_error=True``
    

先看两个示例，了解CheckCommand基本用法：

1. 观察如下回显信息

::

    <Sysname>display interface Ethernet0/1
    Ethernet0/1 current state: UP
    Line protocol current state: UP
    Description: Ethernet0/1 Interface
    The Maximum Transmit Unit is 1500
    Internet Address is 11.91.255.79/24 Primary
    IP Packet Frame Type: PKTFMT_ETHNT_2,  Hardware Address: 5866-ba85-59cf
    IPv6 Packet Frame Type: PKTFMT_ETHNT_2,  Hardware Address: 5866-ba85-59cf

- 期望 ``Line protocol current state: UP`` 和 ``Internet Address is 11.91.255.79/24`` 同时存在，脚本代码如下：

.. code-block:: python
    :linenos:

    gl.DUT.CheckCommand('检查端口信息，预期链路状态UP，IP地址正确', 
                        cmd=f'display interface Ethernet0/1', 
                        expect=['Line protocol current state: UP', f'Internet Address is 11.91.255.79/24'], 
                        is_strict=False, 
                        relationship='and', 
                        stop_max_attempt=3, wait_fixed=2)
                    


2. 观察如下debug信息

::

    <H3C>
    # --------------------------------------- #
    <H3C>*Jan 17 21:01:26:328 2013 H3C IPFW/7/IPFW_PACKET: 
    Receiving, interface = Vlan-interface100, version = 4, headlen = 20, tos = 0,
    pktlen = 110, pktid = 1, offset = 0, ttl = 64, protocol = 0,
    checksum = 34880, s = 13.38.108.1, d = 13.38.108.2
    channelID = 0, vpn-InstanceIn = 0, vpn-InstanceOut = 0.
    prompt: Receiving IP packet.


- 期望debug信息中包含ipv4报文信息：version、源/目的ip，并且其值正确

.. code-block:: python
    :linenos:

    gl.RT.CheckCommand('检查debug信息是否包含ipv4相关信息', 
                    cmd=gl.RT.get_buffer,
                    expect=['version = 4', 's = 13.38.108.1', f'd = 13.38.108.2'],
                    stop_max_attempt=3, wait_fixed=5)


3、基本用法介绍（图片展示）

.. image:: ./images/CheckCommand方法使用介绍1.jpg

``CheckCommand`` 方法支持的参数如下：
  - ``desc``: 检查的描述信息，位置参数，类型为字符串
  - ``cmd`` ：下发的命令行，必选参数，支持字符串类型或get_buffer方法，为字符串时代表要下发的命令行，get_buffer方法为获取缓冲区内容
  - ``timeout``：等待回显的最大时间，单位为秒，可选参数，整型，默认值为15秒。只有当回显时间特别长时，才需要设置。当cmd为get_buffer方法时不生效
  - ``is_full``：返回所有命令行的回显信息，可选参数，布尔型，默认值为False。当cmd为get_buffer方法时不生效
  - ``expect、not_expect`` ：期望存在（不存在）的信息，可选参数，支持字符串、正则表达式编译对象、只包含字符串类型元素的元组或包含这3类元素的的列表
  - ``expect_count`` ：期望存在的信息出现的次数（范围），可选参数，整型或range对象，默认为1，对expect中的所有元素生效，不支持对expect其中一个元素设置expect_count
  - ``table_header`` ：表格检查时，待检查列的列名不能确定唯一表格时，补充的列名，可选参数，列表类型，对expect/not_expect中table元素生效
  - ``is_strict`` ：进行大小写检查，可选参数，默认False，对所有检查方式生效（正则表达式除外）
  - ``relationship`` ：代表期望存在（不存在）的信息的关系，可选参数，支持and/or，默认为and，表示期望的信息都存在，or表示期望的信息存在任意一个都可以
  - ``ignore_cmd_error`` ：忽略命令行下发是否失败，可选参数，布尔型，默认False，表示当命令行下发失败时，检查失败，否则重试
  - ``force_attempt`` ：强制重试，可选参数，布尔型，默认False，进行表格类型检查时，当找不到表头时，检查失败，否则重试
  - ``starts、ends`` ：分别为检查范围开始和结束标识，可选参数，字符串类型，默认检查范围为全部回显信息，否则为回显信息中第一次找到starts和第一次找到ends之间的回显信息
  - ``stop_max_attempt`` ：最大检查次数，如果检查结果正确则提前跳出，默认为1
  - ``wait_fixed`` ：检查两次检查的间隔时间，单位为秒， 默认为0
  - ``failed_assist`` ：检查失败后的辅助信息打印，可选参数，字符串或列表类型，当检查结果为失败后会作为命令行下发给设备并记录回显，当检查结果正确则不做任何处理


----------------
检查方式介绍
----------------


连续字符串检查
~~~~~~~~~~~~~~

连续字符串检查，是指预期在实际回显中连续出现（忽略空格数差异），书写形式为字符串。比如在回显信息

::

    <Sysname>display interface Ethernet0/1
    Ethernet0/1 current state: UP
    Line protocol current state: UP
    Description: Ethernet0/1 Interface
    The Maximum Transmit Unit is 1500
    Internet Address is 11.91.255.79/24 Primary
    IP Packet Frame Type: PKTFMT_ETHNT_2,  Hardware Address: 5866-ba85-59cf
    IPv6 Packet Frame Type: PKTFMT_ETHNT_2,  Hardware Address: 5866-ba85-59cf

- 期望 ``Line protocol current state: UP`` ，则表示以 ``Line`` 和 ``UP`` 为前后边界，依次为 ``protocol current state:``，完整代码如下：

.. code-block:: python
    :linenos:

    gl.DUT.CheckCommand('检查端口信息，预期链路状态UP', 
                    cmd=f'display interface Ethernet0/1', 
                    expect=['Line protocol current state: UP'], 
                    stop_max_attempt=3, wait_fixed=2)

    # 根据检查规则2，如下写法等同第一种写法
    gl.DUT.CheckCommand('检查端口信息，预期链路状态UP', 
                    cmd=f'display interface Ethernet0/1', 
                    expect=['Line    protocol current state          :          UP'], 
                    stop_max_attempt=3, wait_fixed=2)
    
    gl.DUT.CheckCommand('检查端口信息，预期链路状态UP', 
                    cmd=f'display interface Ethernet0/1', 
                    expect=['Line protocol current state:UP'], 
                    stop_max_attempt=3, wait_fixed=2)

- 当期望信息为不完整单词时，需要添加占位符 ``%%%%`` 。期望 ``Internet Address is 11.91.255.79/24 Pri`` ，完整代码如下：

.. code-block:: python
    :linenos:

    # 当期望信息为不完整单词时，需要添加占位符。
    gl.DUT.CheckCommand('检查端口信息，预期ip地址显示正确。Pri为单词Primary部分内容，需要添加占位符', 
                    cmd=f'display interface Ethernet0/1', 
                    expect=['Internet Address is 11.91.255.79/24 Pri%%%%'], 
                    stop_max_attempt=3, wait_fixed=2)


按行不连续字符串检查
~~~~~~~~~~~~~~~~~~~~

按行不连续字符串，指预期的字符串必须在同一行，但可能不是连续出现的，书写形式为元组。比如在回显信息

::

    <Sysname>display segment-routing ipv6 te policy

    Name/ID: p1/0
     End-point: 17::3:3:3:3
     BSID: 
     Mode: Explicit            Type: Type_2              Request state: Succeeded
     Reference counts: 3
     Status: Down
     AdminStatus: Up 
     State: Idle


- 期望 ``Mode: Explicit`` ``Request state: Succeeded`` 在同一行，并且顺次出现，可能连续或不连续，写法为 ``('Mode: Explicit', 'Request state: Succeeded')`` , 完整代码如下：

.. code-block:: python
    :linenos:

    gl.DUT.CheckCommand('检查SRv6 TE Policy信息，预期BSID的模式和BSID申请的状态正确', 
                    cmd=f'display segment-routing ipv6 te policy', 
                    expect=[('Mode: Explicit', 'Request state: Succeeded')], 
                    stop_max_attempt=3, wait_fixed=2)

- 当期望信息为不完整单词时，需要添加占位符 ``%%%%`` 。期望 ``Mode: Explicit`` ``Request state: Succ`` 在同一行 ，完整代码如下：

.. code-block:: python
    :linenos:

    # 当期望信息为不完整单词时，需要添加占位符。
    gl.DUT.CheckCommand('检查SRv6 TE Policy信息，预期BSID的模式和BSID申请的状态正确。Succ为单词Succeeded部分内容，需要添加占位符', 
                    cmd=f'display segment-routing ipv6 te policy', 
                    expect=[('Mode: Explicit', 'Request state: Succ%%%%')], 
                    stop_max_attempt=3, wait_fixed=2)



**检查表格时，推荐使用按表格检查**

按行不连续字符串检查虽然可以用于检查表格，但使用时需要特别注意，必要时添加占位符 ``%%%%``，在如下信息中

::

    <Sysname>display ip routing-table 0.0.0.0

    Summary count : 1

    Destination/Mask   Proto   Pre Cost        NextHop         Interface
    0.0.0.0/32         Direct  1   0           127.0.0.1       InLoop0

- 期望 ``('0.0.0.0/32', '0')`` ，脚本预期 ``Pre`` 列的值为0，但实际上会匹配到 ``Cost`` 列的0，导致误判，在这种情况下需要添加占位符，完整代码如下：

.. code-block:: python
    :linenos:

    gl.DUT.CheckCommand('检查0.0.0.0的路由信息，预期Pre值正确', 
                    cmd=f'display ip routing-table 0.0.0.0', 
                    expect=[('0.0.0.0/32', '%%%%', '0')], 
                    stop_max_attempt=3, wait_fixed=2)


按表格检查
~~~~~~~~~~~

使用按表格检查时，期望的字符串放到 ``_table()`` 内，并以 ``,`` 分隔，其内容必须为偶数个。使用列名和行内容进行定位预期信息，支持检查多列的信息，支持检查多值（如等价路由）。
在预期信息中 ``|`` ``&`` 分别代表或、与关系，其中与关系忽略前后顺序，书写形式为以 ``_table`` 开头的字符串。如在如下信息中

::

    <Sysname> display ip routing-table
 
    Destinations : 10        Routes : 10
    
    Destination/Mask    Proto  Pre  Cost         NextHop         Interface
    0.0.0.0/32          Direct 0    0            127.0.0.1       InLoop0
    1.1.1.0/24          Static 60   0            192.168.47.4    GE1/0/1
                        Static 60   0            192.168.47.4    GE1/0/2
    127.0.0.0/8         Direct 0    0            127.0.0.1       InLoop0
    127.0.0.0/32        Direct 0    0            127.0.0.1       InLoop0

- 期望 Destination/Mask 列存在 ``0.0.0.0/32`` ，并且其 Cost为 ``0``，NextHop 为 ``127.0.0.1`` ，完整代码如下：

.. code-block:: python
    :linenos:

    gl.DUT.CheckCommand('检查路由表信息，预期0.0.0.0的Cost、NextHop值正确', 
                    cmd=f'display ip routing-table', 
                    expect=['_table(Destination/Mask, Cost, NextHop, 0.0.0.0/32, 0, 127.0.0.1)'],
                    stop_max_attempt=3, wait_fixed=2)

- 期望 ``1.1.1.0/24`` 的 NextHop 为 ``192.168.47.4 192.168.47.4`` ，Interface为 ``GE1/0/1 GE1/0/2``，适用于类似等价路由检查，完整代码如下：

.. code-block:: python
    :linenos:

    # 前三个为列名，列名要按实际显示顺序，后三个为各列对应的值
    gl.DUT.CheckCommand('检查路由表信息，预期1.1.1.0的NextHop、Interface值正确', 
                    cmd=f'display ip routing-table', 
                    expect=['_table(Destination/Mask, NextHop, Interface, 1.1.1.0/24, 192.168.47.4&192.168.47.4, GE1/0/2&GE1/0/1)'],
                    stop_max_attempt=3, wait_fixed=2)

    # 与上面的等价，在预期信息中 ``|`` ``&`` 分别代表或、与关系，其中与关系忽略前后顺序
    gl.DUT.CheckCommand('检查路由表信息，预期1.1.1.0的NextHop、Interface值正确', 
                    cmd=f'display ip routing-table', 
                    expect=['_table(Destination/Mask, NextHop, Interface, 1.1.1.0/24, 192.168.47.4&192.168.47.4, GE1/0/1&GE1/0/2)'],
                    stop_max_attempt=3, wait_fixed=2)

    # 或关系示例
    gl.DUT.CheckCommand('检查路由表信息，预期0.0.0.0的Cost值为0或60', 
                    cmd=f'display ip routing-table', 
                    expect=['_table(Destination/Mask, Cost, 0.0.0.0/32, 0|60)'],
                    stop_max_attempt=3, wait_fixed=2)


当给出的列名无法确定唯一表格时，需要使用 ``table_header`` 参数添加列名，用于确定唯一表格。如在如下信息中

::

    <Sysname> display interface brief
    Brief information on interfaces in route mode:
    Link: ADM - administratively down; Stby - standby
    Protocol: (s) – spoofing
    
    Interface            Link Protocol Primary IP      Description
    GE1/0/1              DOWN DOWN     --
    Loop0                UP   UP(s)    2.2.2.9
    NULL0                UP   UP(s)    --
    Vlan1                UP   DOWN     --
    Vlan999              UP   UP       192.168.1.42
    
    Brief information on interfaces in bridge mode:
    Link: ADM - administratively down; Stby - standby
    Speed: (a) - auto
    Duplex: (a)/A - auto; H - half; F - full
    Type: A - access; T - trunk; H - hybrid
    Interface            Link Speed   Duplex Type PVID Description
    GE1/0/2              DOWN auto    A      A    1
    GE1/0/3              UP   auto    F(a)   A    1


- 期望 ``GE1/0/3`` 的 Link 为 ``UP`` ， ``Interface  Link`` 两个列名不能确定唯一表格，使用 ``table_header`` 参数添加列名，用于确定唯一表格，完整代码如下：

.. code-block:: python
    :linenos:

    # 前三个为列名，
    gl.DUT.CheckCommand('检查端口brief信息，预期GE1/0/3的Link值为UP', 
                    cmd=f'display interface brief', 
                    expect=['_table(Interface, Link, GE1/0/3, UP)'],
                    table_header=['Interface', 'PVID'],
                    stop_max_attempt=3, wait_fixed=2)

- 期望 同时检查回显信息中两个列表中的信息，不能指定table_header，需要在 _table() 中分别指定各自的表头，完整代码如下：

.. code-block:: python
    :linenos:

    # 前三个为列名，
    gl.DUT.CheckCommand('检查端口brief信息，预期GE1/0/3的Link值为UP', 
                    cmd=f'display interface brief', 
                    expect=['_table(Interface, Link, Primary IP, Vlan999, UP, 192.168.1.42)', '_table(Interface, Link, PVID, GE1/0/3, UP, 1)'],
                    stop_max_attempt=3, wait_fixed=2)

当给出的列名有部分右对齐时，需要使用占位符 ``%`` 填充列名左起始位置，避免只获取到列内容的部分信息。

在如下信息中， ``AS`` 为右对齐列，当列内容长度大于列名长度时，在设置列名时需要设置为 ``%AS``

::

    VPN instance: 1
    BGP local router ID: 112.1.1.1
    Total number of peers: 2                 Peers in established state: 0
    
    Peer                    AS  MsgRcvd  MsgSent OutQ PrefRcv Up/Down  State

    112.1.1.1              100        0        0    0       0 00:00:06 Established
    112.1.1.2              200        0        0    0       0 00:00:06 Established


- 期望 ``112.1.1.1`` 的 ``AS`` 为 100，由于 ``AS`` 列内容是右对齐，此时添加占位符 ``%`` 设置列名，完整代码如下：

.. code-block:: python
    :linenos:

    # 此时如果指定表头为（Peer, AS, State），得到的AS为00，所以此时要添加%点位符，%占位符的数量要根据AS的值的长度做调整
    # 下面检查项会通过
    gl.DUT.CheckCommand('检查BGP IPv4单播对等体信息，预期112.1.1.1对应的AS、State符合预期',
                cmd='display bgp peer ipv4', 
                expect=['_table(Peer, %AS, State, 112.1.1.1, 100, Established)'])

    # 下面检查项会失败
    gl.DUT.CheckCommand('检查BGP IPv4单播对等体信息，预期112.1.1.1对应的AS、State符合预期',
                cmd='display bgp peer ipv4', 
                expect=['_table(Peer, AS, State, 112.1.1.1, 100, Established)'])


.. admonition:: Note

    1) 表格检查在预期信息中 ``|`` ``&`` 分别代表或、与关系，其中与关系忽略前后顺序；
    
    2) _table()中的参数个数必须为 **偶数个且不少于4个** ，前一半个数对应的值为表头中的列名，后一半为预期行中对应列的值；
    
    3) 表头 table_header 的指定需要按照实际表头的顺序进行指定，表头中包含空格列名，必须在变量 table_header 列表中传入；
    
    4) 如果没有指定入参 table_header，_table() 中的表头必须按照真实顺序指定；

    5) 当需要检查回显信息中多个表格值时，不能指定变量 table_header，只能在各自的 _table() 中指定表头；

    6) 当找不到表头时，默认表头设置错误，默认不进行重试，如需进行重试，设置 ``force_attempt=True`` 强制进行重试；


按分组检查
~~~~~~~~~~~~~~~

按分组检查，期望的字符串放到 ``_group()`` 内，并以 ``,`` 分隔，第一个字符串为分组查找起始信息，其它字符串顺次出现，可能连续或不连续，最后一个字符串为 ``flag=blank_line`` 或 ``flag=indent`` ，
为组信息的分隔符，分别代表 ``空行`` 和 ``缩进`` ，默认 ``空行`` ，书写形式为以 ``_group`` 开头的字符串。在如下信息中

::

    <Sysname> display cfd ais
    Service instance: 5
    AIS level: 4    AIS period: 1s
    MEP ID: 1
    AIS condition: yes   Time to enter the condition: 2019/01/22 10:43:57
    AIS state machine: Previous state: NO_RECEIVE
                       Current state: RECEIVE
    
    Service instance: 20
    AIS level: 3    AIS period: 60s
    MEP ID: 10
    AIS condition: yes   Time to enter the condition: 2019/01/22 10:43:57
    AIS state machine: Previous state: NO_RECEIVE
                       Current state: RECEIVE
    
    Service instance: 100
    AIS level: 6    AIS period: 1s
    MEP ID: 20
    AIS condition: no    Time to enter the condition: 2019/01/22 11:40:01
    AIS state machine: Previous state: IDLE
                       Current state: NO_RECEIVE

- 期望 ``Service instance: 20`` 中包含 ``AIS level: 3`` 和 ``AIS period: 60s`` , 使用空行进行分组，写法为 ``'_group(Service instance: 20, AIS level: 3, AIS period: 60s)'`` ，完整代码如下：

.. code-block:: python
    :linenos:

    gl.DUT.CheckCommand('检查cfd ais的信息，预期Service instance: 20的AIS报文的发送级别和抑制告警的状态正确', 
                    cmd=f'display cfd ais', 
                    expect=['_group(Service instance: 20, AIS level: 3, AIS period: 60s)'], 
                    stop_max_attempt=3, wait_fixed=2)

    # 同时检查Service instance: 20 和 Service instance: 100
    gl.DUT.CheckCommand('检查cfd ais的信息，预期Service instance: 20/100的AIS报文的发送级别和抑制告警的状态正确', 
                    cmd=f'display cfd ais', 
                    expect=['_group(Service instance: 20, AIS level: 3, AIS period: 60s)', 
                        '_group(Service instance: 100, AIS level: 6, AIS period: 1s)'], 
                    stop_max_attempt=3, wait_fixed=2)


当回显信息以缩进分隔时，则需要添加 ``flag=indent`` ，在如下信息中

::

    <Sysname>display ip statistics
    Input:           sum            271           local             165       
                     bad protocol   0             bad format        0         
                     bad checksum   0             bad options       0         
                     dropped        0         
    Output:          forwarding     0             local             821       
                     dropped        0             no route          6         
                     compress fails 0         
    Reassembling:    fragments      0             reassembled       0         
                     dropped        0             timeouts          0         

- 期望 ``Input:`` 中包含 ``sum 271`` ``bad format  0`` ，写法为： ``'_group(Input:, sum 271, bad format  0, flag=indent)'``，完整代码如下：

.. code-block:: python
    :linenos:

    gl.DUT.CheckCommand('检查ip statistics的信息，预期Input的sum和bad format统计正确', 
                    cmd=f'display ip statistics', 
                    expect=['_group(Input:, sum 271, bad format  0, flag=indent)'], 
                    stop_max_attempt=3, wait_fixed=2)

    # 同时检查Input: 和 Output:
    gl.DUT.CheckCommand('检查ip statistics的信息，预期Input/Output的sum、bad format/dropped、no route统计正确', 
                    cmd=f'display ip statistics', 
                    expect=['_group(Input:, sum 271, bad format  0, flag=indent)',
                        '_group(Output:, dropped 0, no route  6, flag=indent)'], 
                    stop_max_attempt=3, wait_fixed=2)



按json格式检查
~~~~~~~~~~~~~~~

按json格式检查，期望的键值放到 ``_json()`` 内，并以 ``,`` 分隔，多对键值时，顺次书写，格式为：键1=值1,键2=值2...。当命令行回显信息不是json格式的字符串时，检查结果为Fail。

键必须以$开头，包含两种书写方式：
 - 以 ``$.`` 开头（如$.DEVICE_METADATA.localhost） 表示返回指定节点的值，此时需要书写绝对路径，节点间使用点(.)分隔
 - 以 ``$..`` 开头（如$..admin_status）表示返回指定节点的所有值，返回值类型为列表

在如下json字符串中

::

    {
        "DEVICE_METADATA": {
            "localhost": {
                "arp_to_route": "true",
                "bgp_asn": "15001",
                "hostname": "TCS81-LA-H3C"
            }
        },
        "PORT": {
            "Eth25GE1": {
                "admin_status": "up",
                "alias": "twentyfiveGigE1",
                "fec": "rs",
                "mtu": "9100",
                "speed": "25000"
            },
            "Eth25GE2": {
                "admin_status": "up",
                "alias": "twentyfiveGigE2",
                "fec": "rs",
                "mtu": "9100",
                "speed": "25000"
            },
            "Eth25GE3": {
                "admin_status": "up",
                "alias": "twentyfiveGigE3",
                "fec": "rs",
                "mtu": "9100",
                "speed": "25000"
            }
        },
        "VLAN": {
            "Vlan2100": {
                "members": [
                    "Eth100GE49"
                ],
                "vlanid": "2100"
            },
            "Vlan3100": {
                "members": [
                    "Eth100GE49"
                ],
                "vlanid": "3100"
            }
        }
    }

- 检查指定节点的值，完整代码如下：

.. code-block:: python
    :linenos:

    dut1.CheckCommand('检查当前配置信息，预期hostname为TCS81-LA-H3C',
                cmd=f'show running config',
                expect=['_json($.DEVICE_METADATA.localhost.hostname=TCS81-LA-H3C)'],
                stop_max_attempt=1, wait_fixed=2)


    dut1.CheckCommand('检查当前配置信息，预期端口Eth25GE1、Eth25GE2的状态都为up',
                    cmd=f'show running config',
                    expect=[f'_json($.PORT.Eth25GE1.admin_status=up,  $.PORT.Eth25GE2.admin_status=up)'],
                    stop_max_attempt=1, wait_fixed=2)


    dut1.CheckCommand('检查当前配置信息，预期所有端口状态为up',
                    cmd=f'show running config',
                    expect=[f"_json($..admin_status=[up, up, up])"],
                    stop_max_attempt=1, wait_fixed=2)


基于正则表达式对象检查
~~~~~~~~~~~~~~~~~~~~~~

当上述检查方式无法满足需求时，用户可以自行编写正则表达式进行检查，期望信息为 ``re.compile`` 对象，检查时直接调用其search属性，需要用户保证compile对象的完整性。在如下信息中

::

    <Sysname>display ospf 1 lsdb network
    
            OSPF Process 1 with Router ID 192.168.1.1
                    Link State Database
    
                            Area: 0.0.0.0
    
        Type      : Network
        LS ID     : 192.168.0.2
        Adv Rtr   : 192.168.2.1
        LS age    : 922
        Len       : 32
        Options   :  E
        Seq#      : 80000003
        Checksum  : 0x8d1b
        Net mask  : 255.255.255.0
        Attached router    192.168.1.1
        Attached router    192.168.2.1

                            Area: 0.0.0.1
    
        Type      : Network
        LS ID     : 192.168.1.2
        Adv Rtr   : 192.168.1.2
        LS age    : 782
        Len       : 32
        Options   :  NP
        Seq#      : 80000003
        Checksum  : 0x2a77
        Net mask  : 255.255.255.0
        Attached router    192.168.1.1
        Attached router    192.168.1.2

- 期望 ``LS ID:192.168.0.2`` ``LS ID : 192.168.1.2`` 分别属于 ``Area：0.0.0.0`` ``Area: 0.0.0.1`` ，完整代码如下：

.. code-block:: python
    :linenos:

    pattern1 = re.compile(r'Area: 0.0.0.0(?!Area:).*LS ID\s+: 192.168.0.2', re.S)
    pattern2 = re.compile(r'Area: 0.0.0.1(?!Area:).*LS ID\s+: 192.168.1.2', re.S)
    gl.DUT.CheckCommand('期望LS ID:192.168.0.2信息在Area：0.0.0.0里', 
                    cmd=f'display ospf 1 lsdb network', 
                    expect=[pattern1, pattern2], 
                    stop_max_attempt=3, wait_fixed=2)

------------------
对数字范围进行检查
------------------

当数字在一个范围，而不是固定值时，可以使用 ``_range()`` 指定范围，该功能不支持正则表达式检查方式，另外 **_range括号内只能是整数，不能带小数点**

在如下信息中

::

    <Sysname>display ip statistics
    Input:           sum            271           local             165       
                     bad protocol   0             bad format        0         
                     bad checksum   0             bad options       0         
                     dropped        0         
    Output:          forwarding     0             local             821       
                     dropped        0             no route          6         
                     compress fails 0         
    Reassembling:    fragments      0             reassembled       0         
                     dropped        0             timeouts          0         

- 期望 ``Input:`` 中 ``270<=sum<=280`` ，写法为： ``'_group(Input:, sum _range(270,280), flag=indent)'``，完整代码如下：

.. code-block:: python
    :linenos:

    gl.DUT.CheckCommand('检查ip statistics的信息，预期Input的sum统计在指定范围', 
                    cmd=f'display ip statistics', 
                    expect=['_group(Input:, sum _range(270,280), flag=indent)'], 
                    stop_max_attempt=3, wait_fixed=2)

    # 同时检查Input: 和 Output:
    gl.DUT.CheckCommand('检查ip statistics的信息，预期Input/Output的sum、bad format/local、no route统计在指定范围', 
                    cmd=f'display ip statistics', 
                    expect=['_group(Input:, sum _range(270,280), bad format  _range(0,3), flag=indent)',
                        '_group(Output:, local _range(800, 900), no route  _range(5,7), flag=indent)'], 
                    stop_max_attempt=3, wait_fixed=2)

---------------
期望不存在检查
---------------

参数 ``not_expect`` 用于在回显信息中检查不存在的信息（支持连续字符串、按行不连续字符串以及正则表达式3种检查方法），与 ``expect`` 参数可同时使用，在如下信息中

::

    <Sysname>display interface Eth0/1
    Ethernet0/1 current state: UP
    Line protocol current state: UP
    Description: Ethernet0/1 Interface
    The Maximum Transmit Unit is 1500
    Internet Address is 11.91.255.79/24 Primary
    IP Packet Frame Type: PKTFMT_ETHNT_2,  Hardware Address: 5866-ba85-59cf
    IPv6 Packet Frame Type: PKTFMT_ETHNT_2,  Hardware Address: 5866-ba85-59cf
    
- 期望 ``current state: Down`` 不存在，完整代码如下：

.. code-block:: python
    :linenos:

    gl.DUT.CheckCommand('检查端口信息，期望Input中packets在指定范围', 
                    cmd=f'display interface Ethernet 0/1', 
                    not_expect=['current state: Down'], 
                    stop_max_attempt=3, wait_fixed=2 )

-----------------
同时检查多个期望
-----------------

不同的检查方法（连续、不连续、表格、分组、正则）可以混合使用，使用 ``relationship`` 设置各期望信息间的 ``与`` ``或`` 关系，默认 ``与`` ，在如下信息中

::

    <Sysname>display interface Eth0/1
    Ethernet0/1 current state: UP
    Line protocol current state: UP
    Description: Ethernet0/1 Interface
    The Maximum Transmit Unit is 1500
    Internet Address is 11.91.255.79/24 Primary
    IP Packet Frame Type: PKTFMT_ETHNT_2,  Hardware Address: 5866-ba85-59cf
    IPv6 Packet Frame Type: PKTFMT_ETHNT_2,  Hardware Address: 5866-ba85-59cf
    Media type is twisted pair, loopback not set, promiscuous mode not set
    100Mb/s, Full-duplex, link type is autonegotiation
    Output flow-control is disabled, input flow-control is disabled
    Output queue : (Urgent queuing : Size/Length/Discards)  0/100/0
    Output queue : (Protocol queuing : Size/Length/Discards)  0/500/0
    Output queue : (FIFO queuing : Size/Length/Discards)  0/75/0
    Last clearing of counters: 19:35:46  Sat 02/04/2023
        Last 300 seconds input rate 0.00 bytes/sec, 0 bits/sec, 0.00 packets/sec
        Last 300 seconds output rate 0.00 bytes/sec, 0 bits/sec, 0.00 packets/sec
        Input: 126 packets, 1793 bytes, 26 buffers
            100 broadcasts, 26 multicasts, 0 pauses
            0 errors, 0 runts, 0 giants
            0 crc, 0 align errors, 0 overruns
            0 dribbles, 0 drops, 0 no buffers
        Output:92 packets, 6959 bytes, 92 buffers
            0 broadcasts, 0 multicasts, 0 pauses
            0 errors, 0 underruns, 0 collisions
            0 deferred, 0 lost carriers

- 期望 ``Line protocol current state: UP`` 存在
- 期望 ``packets`` ``bytes`` ``buffers`` 在同一行
- 期望 ``Input`` 中 ``multicasts`` 介于0和3
- 期望 ``current state: Down`` 不存在

上述各期望为 ``与`` 关系，完整代码如下：


.. code-block:: python
    :linenos:

    # 与关系
    gl.DUT.CheckCommand('检查端口信息，期望各信息正确', 
                    cmd=f'display interface Ethernet 0/1', 
                    expect=['Line protocol current state: UP',
                    ('packets', 'bytes', 'buffers'),
                    '_group(Input:,  _range(0,3) broadcasts, flag=indent)'], 
                    not_expect=['current state: Down'],
                    relationship = 'and',
                    stop_max_attempt=3, wait_fixed=2 )


- 期望 ``Line protocol current state: UP`` 或者 ``The Maximum Transmit Unit is 1500`` 存在，完整代码如下：


.. code-block:: python
    :linenos:

    # 或关系
    gl.DUT.CheckCommand('检查端口信息，期望各信息正确', 
                    cmd=f'display interface Ethernet 0/1', 
                    expect=['Line protocol current state: UP', 'The Maximum Transmit Unit is 1500'], 
                    relationship = 'or',
                    stop_max_attempt=3, wait_fixed=2 )


- 期望多个信息都不存在时，需要使用 ``与`` 关系，如期望 ``Line protocol current state: Down`` 和 ``The Maximum Transmit Unit is 1000`` 不存在，完整代码如下：


.. code-block:: python
    :linenos:

    # 与关系
    gl.DUT.CheckCommand('检查端口信息，期望不存在错误信息', 
                    cmd=f'display interface Ethernet 0/1', 
                    not_expect=['Line protocol current state: Down', 'The Maximum Transmit Unit is 1000'], 
                    relationship = 'and',
                    stop_max_attempt=3, wait_fixed=2 )

--------------------
缩减回显信息检查范围
--------------------

当回显信息比较复杂时，可以通过Comware命令行过滤功能缩减回显信息，也可以通过 ``starts/ends`` 参数指定回显信息的检查范围，该功能对 ``expect`` ``not_expect`` 所有元素生效，在如下信息中

::

    <Sysname>display interface Eth0/1
    Ethernet0/1 current state: UP
    Line protocol current state: UP
    Description: Ethernet0/1 Interface
    The Maximum Transmit Unit is 1500
    Internet Address is 11.91.255.79/24 Primary
    IP Packet Frame Type: PKTFMT_ETHNT_2,  Hardware Address: 5866-ba85-59cf
    IPv6 Packet Frame Type: PKTFMT_ETHNT_2,  Hardware Address: 5866-ba85-59cf
    Media type is twisted pair, loopback not set, promiscuous mode not set
    100Mb/s, Full-duplex, link type is autonegotiation
    Output flow-control is disabled, input flow-control is disabled
    Output queue : (Urgent queuing : Size/Length/Discards)  0/100/0
    Output queue : (Protocol queuing : Size/Length/Discards)  0/500/0
    Output queue : (FIFO queuing : Size/Length/Discards)  0/75/0
    Last clearing of counters: 19:35:46  Sat 02/04/2023
        Last 300 seconds input rate 0.00 bytes/sec, 0 bits/sec, 0.00 packets/sec
        Last 300 seconds output rate 0.00 bytes/sec, 0 bits/sec, 0.00 packets/sec
        Input: 126 packets, 1793 bytes, 26 buffers
            100 broadcasts, 26 multicasts, 0 pauses
            0 errors, 0 runts, 0 giants
            0 crc, 0 align errors, 0 overruns
            0 dribbles, 0 drops, 0 no buffers
        Output:92 packets, 6959 bytes, 92 buffers
            0 broadcasts, 0 multicasts, 0 pauses
            0 errors, 0 underruns, 0 collisions
            0 deferred, 0 lost carriers


- 期望 ``Input`` 中 ``packets`` 介于125和128，使用 ``starts/ends`` 指定查找范围，完整代码如下：

.. code-block:: python
    :linenos:

    gl.DUT.CheckCommand('检查端口信息，期望Input中packets在指定范围', 
                    cmd=f'display interface Ethernet 0/1', expect=['_range(125,128) packets'], 
                    starts='Input:', ends='Output:', 
                    stop_max_attempt=3, wait_fixed=2 )


-------------
命中次数检查
-------------

使用 ``expect_count`` 可以设置某字符串在回显信息中的命中次数（及范围），对参数 ``expect`` 中所有元素生效，不支持单独设置某一字符串的命中次数，可以是一个整数或者range对象，对参数 ``not_expect`` 不生效，在如下信息中

::

    <Sysname>display interface Eth0/1
    Ethernet0/1 current state: UP
    Line protocol current state: UP
    Description: Ethernet0/1 Interface
    The Maximum Transmit Unit is 1500
    Internet Address is 11.91.255.79/24 Primary
    IP Packet Frame Type: PKTFMT_ETHNT_2,  Hardware Address: 5866-ba85-59cf
    IPv6 Packet Frame Type: PKTFMT_ETHNT_2,  Hardware Address: 5866-ba85-59cf


- 期望 ``current state: UP`` 出现2次，完整代码如下：

.. code-block:: python
    :linenos:

    gl.DUT.CheckCommand('检查端口信息，期望current state: UP出现2次', 
                    cmd=f'display interface Ethernet 0/1', 
                    expect=['current state: UP'], expect_count=2, 
                    stop_max_attempt=3, wait_fixed=2 )

    # 对expect参数的所有元素生效，该检查实际结果为失败
    gl.DUT.CheckCommand('检查端口信息，期望current state: UP、ipv6 packet均出现两次', 
                    cmd=f'display interface Ethernet 0/1', 
                    expect=['current state: UP', ('IPv6 Packet', 'PKTFMT_ETHNT_2')], expect_count=2, 
                    stop_max_attempt=3, wait_fixed=2 )

- 期望 ``current state: UP`` 出现1到3次，完整代码如下：

.. code-block:: python
    :linenos:

    gl.DUT.CheckCommand('检查端口信息，期望current state: UP出现1到2次', 
                    cmd=f'display interface Ethernet 0/1', 
                    expect=['current state: UP'], expect_count=range(1,3), 
                    stop_max_attempt=3, wait_fixed=2 )

------------------
设置命令行超时时间
------------------

命令行超时时间默认15s，如果回显信息比较多，默认时间内获取的回显信息不全，为了获取完整的回显信息，需要增加超时时间。

- display interface回显信息多，增加超时时间至200s， ``timeout=200`` ，完整代码如下：

.. code-block:: python
    :linenos:

    gl.DUT.CheckCommand('检查端口信息，期望Line protocol current state: UP出现15次', 
                    cmd=f'display interface', 
                    expect=['Line protocol current state: UP'], expect_count=15, 
                    timeout=200,
                    stop_max_attempt=3, wait_fixed=2 )


------------------
检查失败重试机制
------------------

对于很多有状态的协议，预期信息需要等待一段时间才能出现，不同设备等待时间不同，为了提升执行效率，建议使用重试机制，完整代码如下：

.. code-block:: python
    :linenos:

    # 最多检查3次，每次检查间隔为2秒
    gl.DUT.CheckCommand('检查路由表信息，预期0.0.0.0的NextHop、Interface值正确', 
                    cmd=f'display ip routing-table', 
                    expect=['_table(Destination/Mask, NextHop, Interface, 100.1.1.0/24, 120.1.1.3, GE1/0/3)'],
                    stop_max_attempt=3, wait_fixed=2)


--------------------
忽略下发失败的命令行
--------------------

命令行下发失败时，默认检查结果为失败，并且不会进行重试。如果仍然想进行检查，请使用 ``ignore_cmd_error=True`` 参数，此时重试机制生效。

- 检查ospf aaaa命令行下发失败，提示信息为% Wrong parameter，完整代码如下：

.. code-block:: python
    :linenos:

    gl.DUT.CheckCommand('检查ospf aaaa命令行下发失败，提示信息为% Wrong parameter', 
                    cmd=f'ctrl+z\nsystem-view\nospf aaaa', 
                    expect=['% Wrong parameter'], 
                    ignore_cmd_error=True,
                    stop_max_attempt=3, wait_fixed=2 )

--------------------
表格类检查强制重试
--------------------

进行表格类检查时，当从回显信息中找不到设置的表头时，默认检查结果为失败，并且不会进行重试。如果仍然想进行检查，请使用 ``force_attempt=True`` 参数，此时重试机制生效。

- 检查路由表项，但设置了错误的表头，并要求强制重试，完整代码如下：

.. code-block:: python
    :linenos:

    gl.DUT.dut1.CheckCommand('检查路由表信息，预期0.0.0.0的Cost、NextHop值正确，设置了错误的表头',
                cmd=f'display ip routing-talbe',
                expect=['_table(Source/Mask, Interface, NextHop, 0.0.0.0/32, 0, 127.0.0.1)'],
                force_attempt=True,
                stop_max_attempt=3, wait_fixed=2)


--------------------
检查多条命令行的回显
--------------------

默认情况下，只检查最后一条命令行的回显，然而在某些特殊的场景，需要下发多条命令行，才能保证检查的准确性。此时需要将 ``is_full`` 设置为True，在所有命令行回显信息的进行匹配。  **注意检查时不会区分是哪条命令行的回显，请谨慎使用该参数**

- 端口G1/0/1或G1/0/2处于关闭状态，完整代码如下：

.. code-block:: python
    :linenos:

    gl.DUT.CheckCommand('端口G1/0/1或G1/0/2处于关闭状态', 
                    cmd=f'display current-configuration interface g1/0/1\ndisplay current-configuration interface g1/0/2', 
                    is_full=True,
                    expect=['shutdown'], 
                    ignore_cmd_error=True,
                    stop_max_attempt=3, wait_fixed=2 )


------------------------
自动记录失败辅助定位信息
------------------------

检查失败后，参数 ``failed_assist`` 可以设置自动记录辅助定位信息，在如下信息中

::

    <Sysname>display ip routing-table

    Summary count : 1

    Destination/Mask   Proto   Pre Cost        NextHop         Interface
    0.0.0.0/32         Direct  1   0           127.0.0.1       InLoop0

- 期望 ``100.1.1.1`` 的 NextHop 为 ``120.1.1.3`` ，Interface为 ``GE1/0/3``，失败后记录 ``display interface GE1/0/3`` ``display ospf 1 lsbd brief`` 的回显信息，完整代码如下：

.. code-block:: python
    :linenos:

    # 检查失败，自动记录辅助定位信息
    gl.DUT.CheckCommand('检查路由表信息，预期0.0.0.0的NextHop、Interface值正确', 
                    cmd=f'display ip routing-table', 
                    expect=['_table(Destination/Mask, NextHop, Interface, 100.1.1.0/24, 120.1.1.3, GE1/0/3)'],
                    failed_assist=['display interface GE1/0/3', 'display ospf 1 lsbd brief'],
                    stop_max_attempt=3, wait_fixed=2)


CheckPing
-------------
CheckPing方法用于进行ping操作，并检查通过率，支持大于等于、小于等于关系的检查。

``CheckPing`` 方法支持的参数如下：
  - ``desc``: 检查的描述信息，位置参数，类型为字符串
  - ``dst_address`` ：目的地址，字符串类型，必选参数，可以为ipv4地址、ipv6地址、域名(为域名时要指定ping_mode），例如："138.1.1.1"。
  - ``ping_mode`` ：ipv4 或者 ipv6， 默认为 ipv4，只有dest_address为域名时生效
  - ``src_address``：源地址，字符串类型，如 10.1.1.1
  - ``count`` ：ping的次数，整型int，默认为5
  - ``size`` ：数据包的大小，整型int
  - ``waitmiliseconds`` ：等待时间，整型int
  - ``ttl`` ：最大ttl值，整型int
  - ``vrf_name`` ：vrf名称，字符串类型，如 vrf_general
  - ``pass_rate`` ：预期通过率，整型int，介于0 - 100，代表百分比，如80代表通过率为80%


.. code-block:: python
    :linenos:

    # 通过率设置错误，超过范围，执行后报出错误
    gl.DUT_1.CheckPing('预计可以ping通', gl.RT.PORT3.ip, pass_rate=120, stop_max_attempt=12, wait_fixed=3)

    # 设置ping次数，并且通过率不低于80，就算检查通过
    gl.DUT_1.CheckPing('预计可以ping通', gl.RT.PORT3.ip, count=10, pass_rate=80)

    # 设置ping使用的源地址
    gl.DUT_1.CheckPing('预计可以ping通', gl.RT.PORT3.ip, src_address=gl.DUT_1.PORT1.ip, pass_rate=100)

    # 预期ping不通
    gl.DUT_1.CheckPing('预计ping不通', gl.RT.PORT3.ip, pass_rate=0, stop_max_attempt=2, wait_fixed=3)

    # ipv4 方式 ping 域名，预期pin通
    gl.DUT_1.CheckPing('ping test.com域名，预计ping通', 'test.com', pass_rate=100, stop_max_attempt=2, wait_fixed=3)

    # ipv6 方式 ping 域名，预期pin通
    gl.DUT_1.CheckPing('ping test.com域名，预计ping通', 'test.com', ping_mode='ipv6', pass_rate=100, stop_max_attempt=2, wait_fixed=3)


补充
-----
上述方法是设备类对象下的方法，只能对单台设备的单条命令行的回显进行检查，其它场景（如检查不同设备间命令行回显关系）的命令行检查，需要用户在 ``atf_assert`` 中实现检查逻辑，使用规则见：
:doc:`../用户指导手册/定制检查` 