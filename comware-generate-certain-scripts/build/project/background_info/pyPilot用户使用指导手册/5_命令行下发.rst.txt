.. _topics-命令行下发:


命令行下发
================
新框架下提供两种方式操作comware设备：直接下发命令行、调用封装的方法

----------------
直接下发命令行
----------------
向设备下发命令行是脚本中常见的操作，使用设备对象的 ``send`` 方法完成下发命令行，返回值为 **最后一条命令行的回显**。

例如：

.. code-block:: python
    :linenos:

    # 回到用户视图
    gl.DUT.send('display interface brief')
    
    # 启动 lldp
    gl.DUT.send('''
                   return
                   system-view
                   lldp global enable
                ''')
    
    # 保存当前配置，文件名称startup.cfg，并重写已有文件
    gl.DUT.send('''
                   save
                   Y
                   startup.cfg
                   Y
                ''')

``send`` 方法支持如下参数：

- ``命令行`` : 待下发的命令行，必选参数，字符串类型，该参数为 **位置参数**，支持多个
- ``search`` : 提前结束标识，可选参数，字符串或包含字符串元素的列表，用户通常不需要设置该参数
- ``timeout`` : 每条命令行的最大等待时间，可选参数，整型，单位为秒，默认为15秒
- ``auto_commit`` : 非实时生效视图下自动下发commit命令，可选参数，布尔型，默认为True

.. note:: ``send`` 方法遇到 ``[Y/N]:`` 时，不会自动下发Y，用户需要保证下发的命令行包含必要的Y或N

命令行中变量的写法
------------------
脚本中命令行中的不可避免的会用到变量，**强烈推荐使用f-string格式化**，如：

.. code-block:: python
    :linenos:

    cmds = f'''
                return
                system-view
                interface {gl.DUT.PORT1.name}
                ip address {gl.DUT.PORT1.ip} {gl.DUT.PORT1.mask}
                ip address {gl.DUT.PORT1.ip6} {gl.DUT.PORT1.mask6}'''

自动处理
---------
为了方便脚本编写，send方法提供如下自动处理：

- 自动处理快捷键
    支持的快捷键覆盖所有ASCII表，以及ctrl+p+q，ctrl+相关的快捷键各字符间 **不能有** 空格，支持大小写，非ctrl+的快捷键需要使用<>，如删除键为<DEL>

.. code-block:: python
    :linenos:

    cmds = f'''
            ctrl+zsystem-view
            interface {gl.DUT.PORT1.name}
            ip address {gl.DUT.PORT1.ip} {gl.DUT.PORT1.mask}
            ip address {gl.DUT.PORT1.ip6} {gl.DUT.PORT1.mask6}'''


- 自动处理板卡槽位信息
    有些命令行在分布式设备上需要带上板卡槽位信息（如主控板、接口板、业务板），但在集中式设备上不需要，导致一套脚本很难兼容两种款型的设备比较复杂。

    为了解决该问题，send方法增加自动处理板卡槽位信息功能，只要在命令行中带上 ``_slot(xxx)``，send方法会自动处理。
    
.. code-block:: python
    :linenos:
    
    gl.DUT.send(f'display igmp-snooping static-router-port _slot(master)')
    
    # 上面代码执行后
    # 在集中式设备实际下发
    # display igmp-snooping static-router-port
    
    # 在分布式设备（假设主控板槽位号为0） 实际下发
    # display igmp-snooping static-router-port slot 0

    
    gl.DUT.send(f'display device _slot(GigbitEthernet7/2')
    
    # 上面代码执行后，设备实际下发
    # display device slot 7




- 主动处理help命令
    当命令行最后一个字符为 ``?`` 时，为了避免影响后续命令下发，send方法会主动下发 ``ctrl+x`` ，多条命令行中间如有help命令，则需要用户在命令行中增加 ``ctrl+x``　。

.. code-block:: python
    :linenos:

    # send方法在dir ?下发完成后，主动下发 ctrl+x 
    gl.DUT.send(f'dir ?')
    

.. code-block:: python
    :linenos:

    # wrong_cmds的help命令不是最后一条命令，send方法不主动处理，
    # 命令ip address 100.1.1.1 24下发会叠加前面遗留的ip address命令，导致下发错误
    # right_cmds中添加了ctrl+x命令，则能够正常

    wrong_cmds = f'''
                    ctrl+z
                    system-view
                    interface G1/0/1
                    ip address ?
                    ip address 100.1.1.1 24'''
    
    right_cmds = f'''
                    ctrl+z
                    system-view
                    interface G1/0/1
                    ip address ?
                    ctrl+x
                    ip address 100.1.1.1 24'''


- 自动补充下发commit命令
    非实时生效视图，在命令行下发后，如果视图以 ``*[`` 开头，则会自动补充下发commit命令，保证下发的命令行生效。如果不希望自动补充下发commit命令，使用 ``auto_commit`` 参数关闭该功能
    
.. code-block:: python
    :linenos:
    
    # 自动补充下发commit命令，下面命令真实下发情况如下：
    gl.DUT.send('system-view private\nlldp global enable')
    
    # <H3C>system-view private
    # ~[H3C]lldp global enable
    # *[H3C]commit
    # ~[H3C]
    
    # 如果不希望send方法自动补充下发commit命令时，使用auto_commit参数关闭该功能
    gl.DUT.send('system-view private\nlldp global enable', auto_commit=False)
    
    # <H3C>system-view private
    # ~[H3C]lldp global enable
    # *[H3C]



特殊处理
---------
为了提升命令行下发效率，在如下两种情况send方法会下发 ``screen-length disable`` 命令关闭分屏功能：

  - 重新登录，即屏显出现 ``Press ENTER to get started`` 字符，自动下发回车和 ``screen-length disable`` 命令
  - 回显中包含分屏符 ``---- More ----`` ，自动下发 ``q`` + ``ctrl+z`` 和 ``screen-length disable`` 命令，并重新下发命令行



多设备并行下发命令行
--------------------
send方法只能完成单台设备的命令行下发，想要实现多台设备并行下发命令，需要用到msend方法

msend的入参为不定个参数，每个参数为设备对象、下发命令行、最大等待时间（单位为秒）、提前结束标识（类型为列表）组成的元组。

并发执行是通过多线程调用send方法，所以send方法的“自动处理”和“特殊处理”在并行下命令行时仍然有效。

.. code-block:: python
    :linenos:

    dut1_cmds = f'''
              ctrl+z
              system-view
              interface {gl.DUT1.PORT1.name}
              ip address {gl.DUT1.PORT1.ip} {gl.DUT1.PORT1.mask}
              ip address {gl.DUT1.PORT1.ip6} {gl.DUT1.PORT1.mask6}'''
    
    dut2_cmds = f'''
              ctrl+z
              system-view
              interface {gl.DUT2.PORT1.name}
              ip address {gl.DUT2.PORT1.ip} {gl.DUT2.PORT1.mask}
              ip address {gl.DUT2.PORT1.ip6} {gl.DUT2.PORT1.mask6}'''

    dut3_cmds = f'''
              ctrl+z
              system-view
              interface {gl.DUT3.PORT1.name}
              ip address {gl.DUT3.PORT1.ip} {gl.DUT3.PORT1.mask}
              ip address {gl.DUT3.PORT1.ip6} {gl.DUT3.PORT1.mask6}'''

    msend( (gl.DUT1, dut1_cmds, ), (gl.DUT2, dut2_cmds, ), (gl.DUT3, dut3_cmds, 5) )

.. note:: msend方法不限定设备台数以及设备的命令行数量，但考虑到并发执行有额外的消耗，每台设备命令行下发耗时较短，并且设备台数也不多的情况，可能会出现并发执行的耗时比串行执行的耗时还要长。在此，给出一个大概的评估方法：设备数量少于3，并且每台设备命令行（即时返回）少于10条不使用并发


单设备并行下发命令行
--------------------
msend_single用于完成单台设备的多线程并发。只有设备是网管口连接，并且能够支持多telnet时，才支持并发，否则使用串行下发，同一时间最大线程数为4个。

msend_single入参为不定个参数，第一个参数为设备对象，后续每个参数为下发命令行、最大等待时间（单位为秒）、提前结束标识（类型为列表）组成的元组。

.. code-block:: python
    :linenos:

    cmd1 = '''ctrl+z
              system-view
              ospf 2
              area 0.0.0.0
            '''

    cmd2 = '''ctrl+z
              system-view
              rip 1
            '''

    cmd3 = '''ctrl+z
              system-view
              stp global enable
            '''
    
    cmd4 = '''ctrl+z
              system-view
              bgp 2
            '''

    cmd5 = '''ctrl+z
              system-view
              vlan 100 to 200
            '''

    msend_single(gl.DUT_1, (cmd1, 2, [']']), 
                            (cmd2, 2, [']']), 
                            (cmd3, 2, [']']), 
                            (cmd4, 2, [']']), 
                            (cmd5, 2, [']']))

.. note:: msend_single方法限定单台设备的多线程并发，并发时自动从后台打开/关闭终端，有一定的耗时（约2s），请谨慎使用。另外，send方法的“自动处理”和“特殊处理”在该方法中无效。


----------------
调用封装的方法
----------------
直接下发命令行可以处理绝大部分的设备操作，但有些设备操作包含多个交互过程以及不定时等待（如重启设备），导致整个操作的逻辑比较复杂，
框架将这类操作进行了封装，在脚本中调用封装好的方法，可以有效降低脚本开发的复杂度，提升脚本可移植性。
    

.. list-table:: 方法说明
   :widths: 20 20 30 30
   :header-rows: 1

   * - 操作描述
     - 方法名称
     - 参数说明
     - 使用约束
   * - 保存设备当前配置
     - save_config
     - - filename  可选参数，字符串类型。默认值为空，表示配置文件名称
       - safely    可选参数，布尔型。默认值为False，表示以安全模式保存配置
       - force     可选参数，布尔型。默认值为False，表示以强制模式保存配置
       - context   可选参数。布尔型。默认值为False，将设备上所有context内的配置保存到防火墙插卡的文件系统中
       - mdc       可选参数。布尔型。默认值为False，将设备上所有mdc内的配置
       - all       可选参数，布尔型。默认值为True，表示将当前配置以指定的名称保存到所有主控板
     - 无
   * - 设备重启，并等待重启完成
     - restart
     - - save_config  可选参数，布尔型。默认值为True，表示保存当前配置重启；否则，不保存当前配置重启
       - force        可选参数，布尔型。默认值为False，表示不进行强制重启，否则强制重启
       - wait_stable  可选参数，布尔型。默认值为True，表示等待设备状态恢复到stable
     - 无
   * - 开始设备重启
     - restartbegin
     - - save_config  可选参数，布尔型。默认值为True，表示保存当前配置重启；否则，不保存当前配置重启
       - force        可选参数，布尔型。默认值为False，表示不进行强制重启，否则强制重启
       - to_bootware  可选参数，布尔型。默认为False，表示重启后不进入bootware视图，否则下发ctrl+b进入bootware视图
     - 必须与 restartend 成对儿使用
   * - 等待设备重启完成
     - restartend
     - 无
     - 必须与 restartbegin 成对儿使用
   * - 主备倒换，并等待倒换完成
     - slave_switch
     - - force        可选参数，布尔型。默认值为False，表示不进行强制倒换，否则强制倒换
       - wait_stable  可选参数，布尔型。默认值为True，表示等待设备状态恢复到stable
       - save_config  可选参数，布尔型。默认值为False，表示倒换前是否保存配置文件
     - 无
   * - 开始主备倒换
     - slave_switch_begin
     - - force        可选参数，布尔型。默认值为False，表示不进行强制倒换，否则强制倒换
       - save_config  可选参数，布尔型。默认值为False，表示倒换前是否保存配置文件
     - 必须与 slave_switch_end 成对儿使用
   * - 等待主备倒换完成
     - slave_switch_end
     - 无
     - 必须与 slave_switch_begin 成对儿使用
   * - 重启业务板
     - restart_slot
     - - slot    必选参数，字符串型。支持_slot(standby)、_slot('GigabitEthernet2/0/1')、1、1/11、slot 1等格式
       - force   可选参数，布尔型。默认值为False，表示不进行强制重启，否则强制重启
     - 无
   * - 开始重启业务板
     - restart_slot_begin
     - - slot    必选参数，字符串型。支持_slot(standby)、_slot('GigabitEthernet2/0/1')、1、1/11、slot 1等格式
       - force   可选参数，布尔型。默认值为False，表示不进行强制重启，否则强制重启
     - 必须与 restart_slot_end 成对儿使用
   * - 等待重启业务板完成
     - restart_slot_end
     - - slot    可选参数，字符串型，表示等待指定的板卡重启完成，默认，表示等待所有重启过的板卡重启完成。
     - 必须与 restart_slot_begin 成对儿使用
   * - 清除屏显buffer信息
     - clear_buffer
     - 无
     - 必须与 get_buffer 成对儿使用
   * - 获取屏显buffer信息
     - get_buffer
     - 无
     - 必须与 clear_buffer 成对儿使用
   * - 创建逻辑端口(支持环回和聚合口)
     - create_interface
     - - logic_name      必选参数，字符串型。端口的逻辑名称，表示设备的端口属性，如port1, loop, aggr等
       - physical_name   必选参数，字符串型。端口名称，如 LoopBack 1, Route-Aggregation 1
       - ipv4addr        可选关键字参数，字符串型。要配置的ipv4地址，格式为 x.x.x.x/x
       - ipv6addr        可选关键字参数，字符串型。要配置的ipv4地址，格式为 xx:xx::x/x，
       - member_list     可选关键字参数，列表类型。聚合口的成员端口，如设置该参数，则会自动添加成员端口
     - 与 delete_interface 成对儿使用
   * - 删除逻辑端口(支持环回和聚合口)
     - delete_interface
     - - logic_name      必选参数，字符串型。端口的逻辑名称，表示设备的端口属性，如port1, loop, aggr等
     - 与 create_interface 成对使用
   * - 刷新框架记录的设备各板卡的槽位信息
     - refresh_slot_info
     - 无
     - 堆叠分裂、merge后，主备板槽位可能会变化，自动化框架无法感知，需要在脚本中调用该方法刷新下设备各板卡的槽位信息
   


示例代码：

.. code-block:: python
    :linenos:

    # 保存当前配置
    gl.DUT.save_config()

    # 保存当前配置到dut.cfg文件
    gl.DUT.save_config(filename='dut.cfg')

    # 保存当前配置，重启设备
    gl.DUT.restart(save_config=True)

    # 不保存当前配置，强制重启设备
    gl.DUT.restart(save_config=False, force=True)

    # 保存当前配置，强制重启设备，启动后不等待设备恢复到stable状态，等价于设备出现press enter to start后结束
    gl.DUT.restart(save_config=True, force=True, wait_stable=False)

    # 开始重启设备，do something，等待重启完成，两个接口要成对儿使用
    gl.DUT.restartbegin(save_config=False, force=True)
    print('do something')
    gl.DUT.restartend()

    # 开始重启设备并进入bootware视图，do something，等待重启完成，两个接口要成对儿使用
    gl.DUT.restartbegin(save_config=False, force=True, to_bootware=True)
    print('do something')
    gl.DUT.restartend()


    # 主备倒换
    gl.DUT.slave_switch()

    # 主备倒换，备板启动后不等待设备恢复到stable状态，等价于设备出现press enter to start后结束
    gl.DUT.slave_switch(wait_stable=False)

    # 强制重启端口 DUT.PORT1 所在的板卡
    gl.DUT.restart_slot(slot=f'_slot({gl.DUT.PORT1.intf})', force=True)
    
    # 重启设备备用主控板
    gl.DUT.restart_slot(slot='_slot(standby)', force=False)
   
    
    # ****************** 重启板卡，不等待重启完成 *************************************************
    #
    # 开始重启端口 DUT.PORT1 所在的板卡，不阻塞，然后等待板卡重启完成
    gl.DUT.restart_slot_begin(slot=f'_slot({gl.DUT.PORT1.intf})')
    # do something
    gl.DUT.restart_slot_end()

    # 当同时启动多块板卡时，如果指定等待某块板卡重启完成，传参时要与restart_slot_begin传入的参数一致

    # 开始重启端口 DUT.PORT1 所在的板卡 和 2 号板卡，不阻塞，
    # 等待2号板卡重启完成，再等待 DUT.PORT1 所在的板卡重启完成
    gl.DUT.restart_slot_begin(slot=f'_slot({gl.DUT.PORT1.intf})')
    gl.DUT.restart_slot_begin(slot='2')
    # do something
    gl.DUT.restart_slot_end(slot='2')
    # do something
    gl.DUT.restart_slot_end()
    
    # 开始重启端口 DUT.PORT1 所在的板卡 和 2 号板卡，不阻塞，
    # 等待这两块板卡重启完成
    gl.DUT.restart_slot_begin(slot=f'_slot({gl.DUT.PORT1.intf})')
    gl.DUT.restart_slot_begin(slot='2')
    # do something
    gl.DUT.restart_slot_end()

    # ****************** END **********************************************************************

    # 获取屏显buffer信息 get_buffer 要与 clear_buffer 成对儿使用
    gl.DUT.clear_buffer()
    atf_wait('等待debug信息打印', 5)
    info = gl.DUT.get_buffer()

    # 创建 LoopBack 1，逻辑名称为loop， 并配置ipv4地址 20.1.1.1/24
    # 执行后，可以通过逻辑名称访问该端口属性，如 gl.DUT.loop.ip，其值为20.1.1.1
    gl.DUT.create_interface('loop', 'LoopBack 1', ipv4addr='20.1.1.1/24')
    print(f'创建的逻辑端口LoopBack1的地址为：{gl.DUT.loop.ip}')

    # 删除 LoopBack 1
    gl.DUT.delete_interface('loop')

    # 创建 Route-Aggregation 1，逻辑名称为aggr， 并配置ipv4地址 20.1.1.1/24
    # 自动添加成员端口：进入成员端口后下发 port link-aggregation group 1
    # 执行后，可以通过逻辑名称访问该端口属性，如 gl.DUT.loop.ip，其值为20.1.1.1
    gl.DUT.create_interface('aggr', 'Route-Aggregation 1', ipv4addr='20.1.1.1/24', member_list=['GigabitEthernet 0/1'])
    print(f'创建的逻辑端口Route-Aggregation 1的地址为：{gl.DUT.aggr.ip}')

    # 刷新框架记录的设备各板卡的槽位信息
    gl.DUT.refresh_slot_info()
    
.. note:: 如需其它封装需求，请提供详细需求给自动化组，由自动化负责封装。

-----------------
非实时视图模式
-----------------
框架支持在实时视图模式和非实时视图模式执行脚本，且用户可配置视图模式，默认实时视图模式。

在下发命令行时，框架会做一些额外处理，确保基于实时视图模式开发的脚本，可以在非实时视图模式执行，基于非实时视图模式开发的脚本，则也不受影响。

脚本执行时，分为如下情况：

#. 用户未设置视图模式，设备不支持非实时视图，框架不做额外处理
#. 用户未设置视图模式，设备支持非实时视图，框架自动将进入系统视图的命令行替换为 ``system-view immediate``
#. 用户设置视图模式，设备不支持非实时视图，框架不做额外处理
#. 用户设置视图模式，设备支持非实时视图，框架自动处理设备的配置同步以及下发 ``commit``，其实现规则如下：

  - 用 ``system-view *`` 将命令行分分隔为若干个子命令行
  - 将命令行中的 ``system-view`` 替换为 ``system-view + 视图`` ， ``system-view`` 后面带了视图的，则不替换
  - 下发 ``system-view + 视图`` 时，设备提示正在同步配置，则轮询等待并重试，直至正常进入系统视图，最大等待时间60s
  - 子命令行下发结束后，设备提示符为 ``*[`` 开头的，自动下发 ``commit``

待补充：设置方法


--------------------
多种下发通道选择机制
--------------------
在主网络产品的自动化环境中，通常使用串口服务器或网管口连接设备，串口服务器最为常用，支持的测试更会面，而网管口下发命令效率更高。为了达到最优效率，框架支持动态选择命令行下发通道。

测试床设置见下图：

.. image:: ./images/串口&网管口_测试床.jpg


当设备同时支持串口、网管口连接，框架初始化测试床时自动判断网管口能否Telnet成功：

- 如果可以，则会打开以 ``原终端名称_mgt`` 为名称的终端，后续通过网管口下发命令行
- 否则，使用串口下发


框架默认脚本可以使用网管口下发命令，如果脚本不能使用网管口下发命令行，则需要在脚本中声明类变量 ``atf_is_run_on_manage = False``，该变量对当前拓扑所有设备生效，示例见下图：

.. image:: ./images/串口&网管口_脚本.jpg


.. note:: 已知不能使用网管口的测试有：telnet server相关、RBAC相关、脚本开启 debugging ip packet或debugging ethernet packet（可以通过增加acl规则或指定端口名称进行规避）

